[
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Grep",
    "tool_input": {
      "pattern": "^@app\\.cell\\s*$",
      "path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "output_mode": "content",
      "-A": 1,
      "-n": true
    },
    "tool_response": {
      "mode": "content",
      "numFiles": 0,
      "filenames": [],
      "content": "37:@app.cell\n38-def _():\n--\n43:@app.cell\n44-def _(mo):\n--\n74:@app.cell\n75-def _(mo):\n--\n120:@app.cell\n121-def _():\n--\n152:@app.cell\n153-def _(mo):\n--\n172:@app.cell\n173-def _(\n--\n274:@app.cell\n275-def _(mo):",
      "numLines": 20,
      "appliedLimit": 20
    },
    "tool_use_id": "toolu_01PqcDubHA6tfGBja3ECt5XP"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "offset": 328,
      "limit": 10
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
        "content": "\n@app.cell\ndef _(\n    COMPARISON,\n    add_significance_indicator,\n    apply_prs_style,\n    np,\n    plt,\n    prs_legend,\n):",
        "numLines": 10,
        "startLine": 328,
        "totalLines": 1581
      }
    },
    "tool_use_id": "toolu_01ErzoRGq2cpzW9DuGZPqvNE"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Grep",
    "tool_input": {
      "pattern": "def _\\(COMPARISON.*apply_prs_style.*plt\\):",
      "path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "output_mode": "content",
      "-n": true
    },
    "tool_response": {
      "mode": "content",
      "numFiles": 0,
      "filenames": [],
      "content": "",
      "numLines": 0,
      "appliedLimit": 20
    },
    "tool_use_id": "toolu_01GpxiyrqCtjcpxYV1LeCpCZ"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "offset": 445,
      "limit": 5
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
        "content": "\n@app.cell\ndef _(COMPARISON, apply_prs_style, np, plt, prs_legend):\n    # Example 2: Line graph with confidence intervals\n    def create_example2():",
        "numLines": 5,
        "startLine": 445,
        "totalLines": 1581
      }
    },
    "tool_use_id": "toolu_01Jowj6gTDp1CxGx3pGWoXaL"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "offset": 540,
      "limit": 5
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
        "content": "\n\n@app.cell\ndef _(COMPARISON, apply_prs_style, np, plt, prs_legend):\n    # Example 3: Before/After scatter comparison",
        "numLines": 5,
        "startLine": 540,
        "totalLines": 1581
      }
    },
    "tool_use_id": "toolu_01DrsWNJC7yAnDZ2kBPyS9AH"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "offset": 1130,
      "limit": 5
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
        "content": "    \"\"\")\n    return\n\n\n@app.cell",
        "numLines": 5,
        "startLine": 1130,
        "totalLines": 1581
      }
    },
    "tool_use_id": "toolu_01BtPYUBjmYoAbnrJMQp6nqV"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "offset": 1133,
      "limit": 15
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
        "content": "\n@app.cell\ndef _(CLINICAL_DATA, COMPARISON, apply_prs_style, np, plt):\n    # Example 6: Multi-Panel Grouped Bar Charts\n    def create_example6():\n        \"\"\"Create multi-panel grouped bar charts for outcome comparison.\"\"\"\n        apply_prs_style(cycle=\"comparison\")\n\n        # Define categories and data\n        categories = [\n            \"30 Day\\nComplications\",\n            \"Complications\\nBefore Discharge\",\n            \"Growth\\nDelay\",\n            \"Revision\\nPerformed\",\n            \"Speech\\nTherapy\",",
        "numLines": 15,
        "startLine": 1133,
        "totalLines": 1581
      }
    },
    "tool_use_id": "toolu_01MCUwSfTHTHmhw641hSaXbX"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "def _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels",
      "new_string": "def _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "def _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels",
      "newString": "def _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: fontsize, title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 525,
          "oldLines": 6,
          "newStart": 525,
          "newLines": 34,
          "lines": [
            "     return labels",
            " ",
            " ",
            "+def _is_bar_chart(ax):",
            "+    \"\"\"",
            "+    Detect if axes contains bar chart (bar or barh plot).",
            "+",
            "+    Parameters",
            "+    ----------",
            "+    ax : matplotlib.axes.Axes",
            "+        Axes to check.",
            "+",
            "+    Returns",
            "+    -------",
            "+    bool",
            "+        True if axes contains bar patches (bar chart).",
            "+    \"\"\"",
            "+    from matplotlib.patches import Rectangle",
            "+",
            "+    # Check if any patches are bar-like (rectangles)",
            "+    for patch in ax.patches:",
            "+        if isinstance(patch, Rectangle):",
            "+            return True",
            "+",
            "+    # Also check containers (grouped/stacked bars)",
            "+    if hasattr(ax, 'containers') and ax.containers:",
            "+        return True",
            "+",
            "+    return False",
            "+",
            "+",
            " def prs_legend(",
            "     ax,",
            "     *args,"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01TnMcDxa91o4G5trB57nzQe"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    **kwargs\n) -> None:",
      "new_string": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    **kwargs\n) -> None:",
      "newString": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: fontsize, title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 559,
          "oldLines": 6,
          "newStart": 559,
          "newLines": 7,
          "lines": [
            "     position: str = \"best\",",
            "     compact: bool = False,",
            "     ncol: int = None,",
            "+    fontsize: int = None,",
            "     **kwargs",
            " ) -> None:",
            "     \"\"\""
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_017J8EshpyGoPBZ9VSvQyBFj"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: fontsize, title, markerscale, bbox_to_anchor",
      "new_string": "    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: fontsize, title, markerscale, bbox_to_anchor",
      "newString": "    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: fontsize, title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 584,
          "oldLines": 9,
          "newStart": 584,
          "newLines": 13,
          "lines": [
            "         - Number of labels",
            "         - Label text length",
            "         - Position type (more columns for \"top\", fewer for vertical positions)",
            "+    fontsize : int, optional",
            "+        Font size for legend text. If None, uses matplotlib default (usually 10-12).",
            "+        Recommended: Use same fontsize for axes labels, tick labels, and legend",
            "+        for consistent professional appearance.",
            "     *args, **kwargs",
            "         Additional arguments passed to ax.legend().",
            "-        Common options: fontsize, title, markerscale, bbox_to_anchor",
            "+        Common options: title, markerscale, bbox_to_anchor",
            " ",
            "     Examples",
            "     --------"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01HruAVSXN76EJNFsqww5RaY"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)",
      "new_string": "    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)",
      "newString": "    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Fixed top positioning with 2 columns:\n    >>> prs_legend(ax, position=\"top\", ncol=2)\n\n    Outside with auto columns:\n    >>> prs_legend(ax, position=\"outside\")\n\n    Custom positioning with auto columns and compact spacing:\n    >>> prs_legend(ax, position=\"upper left\", compact=True)\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 603,
          "oldLines": 15,
          "newStart": 603,
          "newLines": 18,
          "lines": [
            "     Smart top positioning (auto-calculates columns):",
            "     >>> prs_legend(ax, position=\"top-smart\")",
            " ",
            "-    Fixed top positioning with 2 columns:",
            "-    >>> prs_legend(ax, position=\"top\", ncol=2)",
            "+    Standardized font size across figure:",
            "+    >>> fontsize = 14",
            "+    >>> ax.tick_params(labelsize=fontsize)",
            "+    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)",
            "+    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)",
            "+    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)",
            " ",
            "-    Outside with auto columns:",
            "-    >>> prs_legend(ax, position=\"outside\")",
            "+    Bar chart with prominent legend (auto-detected):",
            "+    >>> fig, ax = plt.subplots()",
            "+    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")",
            "+    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars",
            " ",
            "-    Custom positioning with auto columns and compact spacing:",
            "-    >>> prs_legend(ax, position=\"upper left\", compact=True)",
            "-",
            "     Notes",
            "     -----",
            "     **Smart Column Calculation:**"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_011KA5s5rX8A8doSTAX9tmKV"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot",
      "new_string": "    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot",
      "newString": "    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 629,
          "oldLines": 10,
          "newStart": 629,
          "newLines": 26,
          "lines": [
            "     - `position=\"top-smart\"` auto-positions above plot with optimal column count",
            "     - Works best for plots WITHOUT titles (common in PRS manuscripts)",
            " ",
            "+    **Auto-Detection for Bar Charts:**",
            "+    When the axes contains bar charts (bar/barh), automatically applies:",
            "+    - `markerscale=4` (4\u00d7 larger handles for visibility)",
            "+    - `handleheight=2` (taller color boxes)",
            "+    - `handlelength=2` (standard width)",
            "+    These make bar chart legends more prominent and professional.",
            "+",
            "+    **Font Size Standardization:**",
            "+    Use the same `fontsize` parameter for axes labels and legend:",
            "+    ```python",
            "+    fontsize = 14",
            "+    ax.tick_params(labelsize=fontsize)",
            "+    ax.set_xlabel(\"Label\", fontsize=fontsize)",
            "+    prs_legend(ax, position=\"top\", fontsize=fontsize)",
            "+    ```",
            "+",
            "     **Position-Specific Defaults:**",
            "-    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol",
            "+    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing",
            "     - \"outside\": Framed, right side, vertically centered",
            "-    - \"best\": Framed, automatic placement inside plot",
            "+    - \"best\": Framed, automatic placement inside plot, avoids overlap",
            "     \"\"\"",
            "     # Auto-calculate ncol if not provided",
            "     if ncol is None:"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01WWYPFs9V99E7CJks8vPQ9r"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)",
      "new_string": "    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Auto-detect bar charts and apply prominent handle settings\n    is_bar = _is_bar_chart(ax)\n    if is_bar:\n        # Bar charts need larger, more visible legend handles\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)",
      "newString": "    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Auto-detect bar charts and apply prominent handle settings\n    is_bar = _is_bar_chart(ax)\n    if is_bar:\n        # Bar charts need larger, more visible legend handles\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 664,
          "oldLines": 6,
          "newStart": 664,
          "newLines": 14,
          "lines": [
            "             # Other positions: balanced approach",
            "             ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)",
            " ",
            "+    # Auto-detect bar charts and apply prominent handle settings",
            "+    is_bar = _is_bar_chart(ax)",
            "+    if is_bar:",
            "+        # Bar charts need larger, more visible legend handles",
            "+        kwargs.setdefault(\"markerscale\", 4)",
            "+        kwargs.setdefault(\"handleheight\", 2)",
            "+        kwargs.setdefault(\"handlelength\", 2)",
            "+",
            "     # Position-specific defaults",
            "     if position == \"outside\":",
            "         kwargs.setdefault(\"loc\", \"center left\")"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01NZPPyoeJBwhEHmav9EHkcR"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)",
      "new_string": "    # Common defaults (can be overridden by kwargs)\n    if fontsize is not None:\n        kwargs.setdefault(\"fontsize\", fontsize)\n    else:\n        kwargs.setdefault(\"fontsize\", 12)\n\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)",
      "newString": "    # Common defaults (can be overridden by kwargs)\n    if fontsize is not None:\n        kwargs.setdefault(\"fontsize\", fontsize)\n    else:\n        kwargs.setdefault(\"fontsize\", 12)\n\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Auto-detect bar charts and apply prominent handle settings\n    is_bar = _is_bar_chart(ax)\n    if is_bar:\n        # Bar charts need larger, more visible legend handles\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n        kwargs.setdefault(\"markerscale\", 4)\n\n    # Common defaults (can be overridden by kwargs)\n    kwargs.setdefault(\"fontsize\", 12)\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 730,
          "oldLines": 7,
          "newStart": 730,
          "newLines": 11,
          "lines": [
            "         kwargs.setdefault(\"markerscale\", 4)",
            " ",
            "     # Common defaults (can be overridden by kwargs)",
            "-    kwargs.setdefault(\"fontsize\", 12)",
            "+    if fontsize is not None:",
            "+        kwargs.setdefault(\"fontsize\", fontsize)",
            "+    else:",
            "+        kwargs.setdefault(\"fontsize\", 12)",
            "+",
            "     kwargs.setdefault(\"title\", \"\")",
            " ",
            "     ax.legend(*args, **kwargs)"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_0169x26WT6LKyMufj1fy2Xtk"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
      "offset": 55,
      "limit": 20
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
        "content": "# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n)\n\n# Export exports\nfrom .export import (\n    save_prs_figure,\n    save_multi_panel_figure,\n    validate_figure_file,\n    PRS_MIN_DPI,\n    PRS_MIN_WIDTH_SINGLE,\n    PRS_MIN_WIDTH_GRAPH,\n)\n",
        "numLines": 20,
        "startLine": 55,
        "totalLines": 146
      }
    },
    "tool_use_id": "toolu_011s3cyAAX1gvJPg3wwVCkMK"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
      "old_string": "# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n)",
      "new_string": "# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n    set_axis_fontsize,\n)"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
      "oldString": "# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n)",
      "newString": "# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n    set_axis_fontsize,\n)",
      "originalFile": "\"\"\"\nPRS DataViz: Professional Data Visualization for PRS Journal Submissions\n\nA comprehensive design system for creating publication-quality figures for\nPlastic and Reconstructive Surgery (PRS) journal submissions.\n\nFeatures:\n- PRS-compliant figure export (300+ DPI, CMYK, proper formats)\n- Professional color palettes (CMYK-safe, colorblind-friendly)\n- Before/after comparison layouts\n- Multi-panel figure utilities\n- Accessibility-focused design (Cara Thompson's methodology)\n\nQuick Start:\n    >>> from prs_dataviz import apply_prs_style, save_prs_figure\n    >>> import matplotlib.pyplot as plt\n    >>>\n    >>> apply_prs_style(cycle=\"clinical\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n    >>> save_prs_figure(fig, \"figure1.tiff\", dpi=300, width_inches=5.0)\n\nReferences:\n- PRS Figure Guidelines: https://journals.lww.com/plasreconsurg/\n- Cara Thompson's Accessibility Methodology:\n  https://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\n__version__ = \"0.1.0\"\n\n# Palette exports\nfrom .palettes import (\n    # Color families\n    CLINICAL_BLUE,\n    TISSUE_TONE,\n    CLINICAL_DATA,\n    COMPARISON,\n    STATISTICAL,\n    COLOR_FAMILIES,\n    # Categorical palettes\n    CATEGORICAL,\n    # Sequential palettes\n    SEQUENTIAL_BLUES,\n    # Diverging palettes\n    DIVERGING,\n    # Cycles\n    PRS_DEFAULT_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_CLINICAL_CYCLE,\n    # Utilities\n    rgb_to_cmyk,\n    cmyk_to_rgb,\n)\n\n# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n)\n\n# Export exports\nfrom .export import (\n    save_prs_figure,\n    save_multi_panel_figure,\n    validate_figure_file,\n    PRS_MIN_DPI,\n    PRS_MIN_WIDTH_SINGLE,\n    PRS_MIN_WIDTH_GRAPH,\n)\n\n# Layout exports\nfrom .layout import (\n    create_before_after_figure,\n    create_multi_view_figure,\n    create_time_series_figure,\n    create_results_panel,\n)\n\n# Helper exports\nfrom .helpers import (\n    auto_extend_ylim,\n    get_data_max_in_range,\n    auto_calculate_ylim_for_annotations,\n    auto_position_brackets,\n    calculate_bracket_position,\n    add_comparison_bars,\n    add_multiple_comparisons,\n    create_comparison_plot,\n    create_time_series_plot,\n    get_significance_symbol,\n    calculate_optimal_ylim,\n)\n\n__all__ = [\n    # Palettes\n    \"CLINICAL_BLUE\",\n    \"TISSUE_TONE\",\n    \"CLINICAL_DATA\",\n    \"COMPARISON\",\n    \"STATISTICAL\",\n    \"COLOR_FAMILIES\",\n    \"CATEGORICAL\",\n    \"SEQUENTIAL_BLUES\",\n    \"DIVERGING\",\n    \"PRS_DEFAULT_CYCLE\",\n    \"PRS_COMPARISON_CYCLE\",\n    \"PRS_CLINICAL_CYCLE\",\n    \"rgb_to_cmyk\",\n    \"cmyk_to_rgb\",\n    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",\n    # Export\n    \"save_prs_figure\",\n    \"save_multi_panel_figure\",\n    \"validate_figure_file\",\n    \"PRS_MIN_DPI\",\n    \"PRS_MIN_WIDTH_SINGLE\",\n    \"PRS_MIN_WIDTH_GRAPH\",\n    # Layout\n    \"create_before_after_figure\",\n    \"create_multi_view_figure\",\n    \"create_time_series_figure\",\n    \"create_results_panel\",\n    # Helpers\n    \"auto_extend_ylim\",\n    \"get_data_max_in_range\",\n    \"auto_calculate_ylim_for_annotations\",\n    \"auto_position_brackets\",\n    \"calculate_bracket_position\",\n    \"add_comparison_bars\",\n    \"add_multiple_comparisons\",\n    \"create_comparison_plot\",\n    \"create_time_series_plot\",\n    \"get_significance_symbol\",\n    \"calculate_optimal_ylim\",\n]\n",
      "structuredPatch": [
        {
          "oldStart": 60,
          "oldLines": 6,
          "newStart": 60,
          "newLines": 7,
          "lines": [
            "     add_significance_indicator,",
            "     add_scale_bar,",
            "     prs_legend,",
            "+    set_axis_fontsize,",
            " )",
            " ",
            " # Export exports"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01S4iHaRwQezYhVXHykae3KX"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
      "old_string": "    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",",
      "new_string": "    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",\n    \"set_axis_fontsize\","
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
      "oldString": "    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",",
      "newString": "    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",\n    \"set_axis_fontsize\",",
      "originalFile": "\"\"\"\nPRS DataViz: Professional Data Visualization for PRS Journal Submissions\n\nA comprehensive design system for creating publication-quality figures for\nPlastic and Reconstructive Surgery (PRS) journal submissions.\n\nFeatures:\n- PRS-compliant figure export (300+ DPI, CMYK, proper formats)\n- Professional color palettes (CMYK-safe, colorblind-friendly)\n- Before/after comparison layouts\n- Multi-panel figure utilities\n- Accessibility-focused design (Cara Thompson's methodology)\n\nQuick Start:\n    >>> from prs_dataviz import apply_prs_style, save_prs_figure\n    >>> import matplotlib.pyplot as plt\n    >>>\n    >>> apply_prs_style(cycle=\"clinical\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n    >>> save_prs_figure(fig, \"figure1.tiff\", dpi=300, width_inches=5.0)\n\nReferences:\n- PRS Figure Guidelines: https://journals.lww.com/plasreconsurg/\n- Cara Thompson's Accessibility Methodology:\n  https://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\n__version__ = \"0.1.0\"\n\n# Palette exports\nfrom .palettes import (\n    # Color families\n    CLINICAL_BLUE,\n    TISSUE_TONE,\n    CLINICAL_DATA,\n    COMPARISON,\n    STATISTICAL,\n    COLOR_FAMILIES,\n    # Categorical palettes\n    CATEGORICAL,\n    # Sequential palettes\n    SEQUENTIAL_BLUES,\n    # Diverging palettes\n    DIVERGING,\n    # Cycles\n    PRS_DEFAULT_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_CLINICAL_CYCLE,\n    # Utilities\n    rgb_to_cmyk,\n    cmyk_to_rgb,\n)\n\n# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n    set_axis_fontsize,\n)\n\n# Export exports\nfrom .export import (\n    save_prs_figure,\n    save_multi_panel_figure,\n    validate_figure_file,\n    PRS_MIN_DPI,\n    PRS_MIN_WIDTH_SINGLE,\n    PRS_MIN_WIDTH_GRAPH,\n)\n\n# Layout exports\nfrom .layout import (\n    create_before_after_figure,\n    create_multi_view_figure,\n    create_time_series_figure,\n    create_results_panel,\n)\n\n# Helper exports\nfrom .helpers import (\n    auto_extend_ylim,\n    get_data_max_in_range,\n    auto_calculate_ylim_for_annotations,\n    auto_position_brackets,\n    calculate_bracket_position,\n    add_comparison_bars,\n    add_multiple_comparisons,\n    create_comparison_plot,\n    create_time_series_plot,\n    get_significance_symbol,\n    calculate_optimal_ylim,\n)\n\n__all__ = [\n    # Palettes\n    \"CLINICAL_BLUE\",\n    \"TISSUE_TONE\",\n    \"CLINICAL_DATA\",\n    \"COMPARISON\",\n    \"STATISTICAL\",\n    \"COLOR_FAMILIES\",\n    \"CATEGORICAL\",\n    \"SEQUENTIAL_BLUES\",\n    \"DIVERGING\",\n    \"PRS_DEFAULT_CYCLE\",\n    \"PRS_COMPARISON_CYCLE\",\n    \"PRS_CLINICAL_CYCLE\",\n    \"rgb_to_cmyk\",\n    \"cmyk_to_rgb\",\n    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",\n    # Export\n    \"save_prs_figure\",\n    \"save_multi_panel_figure\",\n    \"validate_figure_file\",\n    \"PRS_MIN_DPI\",\n    \"PRS_MIN_WIDTH_SINGLE\",\n    \"PRS_MIN_WIDTH_GRAPH\",\n    # Layout\n    \"create_before_after_figure\",\n    \"create_multi_view_figure\",\n    \"create_time_series_figure\",\n    \"create_results_panel\",\n    # Helpers\n    \"auto_extend_ylim\",\n    \"get_data_max_in_range\",\n    \"auto_calculate_ylim_for_annotations\",\n    \"auto_position_brackets\",\n    \"calculate_bracket_position\",\n    \"add_comparison_bars\",\n    \"add_multiple_comparisons\",\n    \"create_comparison_plot\",\n    \"create_time_series_plot\",\n    \"get_significance_symbol\",\n    \"calculate_optimal_ylim\",\n]\n",
      "structuredPatch": [
        {
          "oldStart": 119,
          "oldLines": 6,
          "newStart": 119,
          "newLines": 7,
          "lines": [
            "     \"add_significance_indicator\",",
            "     \"add_scale_bar\",",
            "     \"prs_legend\",",
            "+    \"set_axis_fontsize\",",
            "     # Export",
            "     \"save_prs_figure\",",
            "     \"save_multi_panel_figure\","
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_0192WeHmxMi3Dt1KgSGojM2q"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py"
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/__init__.py",
        "content": "\"\"\"\nPRS DataViz: Professional Data Visualization for PRS Journal Submissions\n\nA comprehensive design system for creating publication-quality figures for\nPlastic and Reconstructive Surgery (PRS) journal submissions.\n\nFeatures:\n- PRS-compliant figure export (300+ DPI, CMYK, proper formats)\n- Professional color palettes (CMYK-safe, colorblind-friendly)\n- Before/after comparison layouts\n- Multi-panel figure utilities\n- Accessibility-focused design (Cara Thompson's methodology)\n\nQuick Start:\n    >>> from prs_dataviz import apply_prs_style, save_prs_figure\n    >>> import matplotlib.pyplot as plt\n    >>>\n    >>> apply_prs_style(cycle=\"clinical\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n    >>> save_prs_figure(fig, \"figure1.tiff\", dpi=300, width_inches=5.0)\n\nReferences:\n- PRS Figure Guidelines: https://journals.lww.com/plasreconsurg/\n- Cara Thompson's Accessibility Methodology:\n  https://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\n__version__ = \"0.1.0\"\n\n# Palette exports\nfrom .palettes import (\n    # Color families\n    CLINICAL_BLUE,\n    TISSUE_TONE,\n    CLINICAL_DATA,\n    COMPARISON,\n    STATISTICAL,\n    COLOR_FAMILIES,\n    # Categorical palettes\n    CATEGORICAL,\n    # Sequential palettes\n    SEQUENTIAL_BLUES,\n    # Diverging palettes\n    DIVERGING,\n    # Cycles\n    PRS_DEFAULT_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_CLINICAL_CYCLE,\n    # Utilities\n    rgb_to_cmyk,\n    cmyk_to_rgb,\n)\n\n# Style exports\nfrom .style import (\n    apply_prs_style,\n    format_statistical_plot,\n    format_comparison_plot,\n    add_significance_indicator,\n    add_scale_bar,\n    prs_legend,\n    set_axis_fontsize,\n)\n\n# Export exports\nfrom .export import (\n    save_prs_figure,\n    save_multi_panel_figure,\n    validate_figure_file,\n    PRS_MIN_DPI,\n    PRS_MIN_WIDTH_SINGLE,\n    PRS_MIN_WIDTH_GRAPH,\n)\n\n# Layout exports\nfrom .layout import (\n    create_before_after_figure,\n    create_multi_view_figure,\n    create_time_series_figure,\n    create_results_panel,\n)\n\n# Helper exports\nfrom .helpers import (\n    auto_extend_ylim,\n    get_data_max_in_range,\n    auto_calculate_ylim_for_annotations,\n    auto_position_brackets,\n    calculate_bracket_position,\n    add_comparison_bars,\n    add_multiple_comparisons,\n    create_comparison_plot,\n    create_time_series_plot,\n    get_significance_symbol,\n    calculate_optimal_ylim,\n)\n\n__all__ = [\n    # Palettes\n    \"CLINICAL_BLUE\",\n    \"TISSUE_TONE\",\n    \"CLINICAL_DATA\",\n    \"COMPARISON\",\n    \"STATISTICAL\",\n    \"COLOR_FAMILIES\",\n    \"CATEGORICAL\",\n    \"SEQUENTIAL_BLUES\",\n    \"DIVERGING\",\n    \"PRS_DEFAULT_CYCLE\",\n    \"PRS_COMPARISON_CYCLE\",\n    \"PRS_CLINICAL_CYCLE\",\n    \"rgb_to_cmyk\",\n    \"cmyk_to_rgb\",\n    # Style\n    \"apply_prs_style\",\n    \"format_statistical_plot\",\n    \"format_comparison_plot\",\n    \"add_significance_indicator\",\n    \"add_scale_bar\",\n    \"prs_legend\",\n    \"set_axis_fontsize\",\n    # Export\n    \"save_prs_figure\",\n    \"save_multi_panel_figure\",\n    \"validate_figure_file\",\n    \"PRS_MIN_DPI\",\n    \"PRS_MIN_WIDTH_SINGLE\",\n    \"PRS_MIN_WIDTH_GRAPH\",\n    # Layout\n    \"create_before_after_figure\",\n    \"create_multi_view_figure\",\n    \"create_time_series_figure\",\n    \"create_results_panel\",\n    # Helpers\n    \"auto_extend_ylim\",\n    \"get_data_max_in_range\",\n    \"auto_calculate_ylim_for_annotations\",\n    \"auto_position_brackets\",\n    \"calculate_bracket_position\",\n    \"add_comparison_bars\",\n    \"add_multiple_comparisons\",\n    \"create_comparison_plot\",\n    \"create_time_series_plot\",\n    \"get_significance_symbol\",\n    \"calculate_optimal_ylim\",\n]\n",
        "numLines": 148,
        "startLine": 1,
        "totalLines": 148
      }
    },
    "tool_use_id": "toolu_01UsRjAjmDVCEJDvh4Dfaa7j"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "old_string": "    **PRS-DataViz Smart Legend Features:**\n\n    1. **`prs_legend(ax, position=\"top-smart\")`**\n       - **Auto-calculates columns** based on label text length\n       - Short labels (< 15 chars avg): 2-4 columns\n       - Medium labels (15-25 chars): 2-3 columns\n       - Long labels (> 25 chars): 1-2 columns\n       - Very long labels (> 40 chars): 1 column\n\n    2. **Dynamic `bbox_to_anchor` Positioning**\n       - 1 column: `x=0.5` (centered)\n       - 2 columns: `x=0.35` (slightly left)\n       - 3 columns: `x=0.4` (balanced)\n       - 4+ columns: `x=0.45` (nearly centered)\n\n    3. **Smart Overlap Avoidance**\n       - Use `position=\"best\"` for automatic placement inside plot\n       - Matplotlib's algorithm finds position with minimal data overlap\n       - Perfect for plots without titles (common in PRS manuscripts)\n\n    **Usage Examples:**\n    ```python\n    # Fully automatic (recommended)\n    prs_legend(ax, position=\"top-smart\")\n\n    # Manual override if needed\n    prs_legend(ax, position=\"top\", ncol=2)\n\n    # Smart inside positioning (avoids data overlap)\n    prs_legend(ax, position=\"best\")\n    ```\n\n    **Key Benefits:**\n    - \u2705 No manual `ncol` calculation needed\n    - \u2705 Optimal positioning based on label length\n    - \u2705 Consistent professional appearance\n    - \u2705 Works perfectly for no-title plots (PRS standard)\n\n    **Use Cases:** Any plot with legends, especially when label lengths vary or you want automatic optimal layout",
      "new_string": "    **PRS-DataViz Smart Legend Features:**\n\n    1. **Auto-Calculates Columns** (based on label text length)\n       - Short labels (< 15 chars avg): 2-4 columns\n       - Medium labels (15-25 chars): 2-3 columns\n       - Long labels (> 25 chars): 1-2 columns\n       - Very long labels (> 40 chars): 1 column\n\n    2. **Auto-Detects Bar Charts** (applies prominent handles automatically)\n       - `markerscale=4` \u2192 4\u00d7 larger markers\n       - `handleheight=2` \u2192 Taller color boxes\n       - `handlelength=2` \u2192 Standard width\n       - Makes bar legends highly visible and professional\n\n    3. **Dynamic `bbox_to_anchor` Positioning**\n       - 1 column: `x=0.5` (centered)\n       - 2 columns: `x=0.35` (slightly left)\n       - 3 columns: `x=0.4` (balanced)\n       - 4+ columns: `x=0.45` (nearly centered)\n\n    4. **Smart Overlap Avoidance**\n       - Use `position=\"best\"` for automatic placement\n       - Matplotlib's algorithm finds position with minimal data overlap\n\n    **Font Size Standardization:**\n    ```python\n    # Method 1: Manual standardization\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Time\", fontsize=fontsize)\n    ax.set_ylabel(\"Response\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    # Method 2: Helper function\n    from prs_dataviz import set_axis_fontsize\n    set_axis_fontsize(ax, fontsize=14)\n    prs_legend(ax, position=\"top\", fontsize=14)\n    ```\n\n    **Usage Examples:**\n    ```python\n    # Fully automatic (recommended for bar charts)\n    prs_legend(ax, position=\"top-smart\")\n\n    # With standardized font size\n    prs_legend(ax, position=\"top\", fontsize=14)\n\n    # Smart inside positioning (avoids data overlap)\n    prs_legend(ax, position=\"best\")\n    ```\n\n    **Key Benefits:**\n    - \u2705 Bar charts automatically get prominent handles\n    - \u2705 No manual `ncol` calculation needed\n    - \u2705 Standardized font sizing across figure\n    - \u2705 Works perfectly for no-title plots (PRS standard)\n\n    **Use Cases:** Bar charts, stacked charts, any plot where you want automatic optimal legend layout"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/notebooks/prs_gallery.py",
      "oldString": "    **PRS-DataViz Smart Legend Features:**\n\n    1. **`prs_legend(ax, position=\"top-smart\")`**\n       - **Auto-calculates columns** based on label text length\n       - Short labels (< 15 chars avg): 2-4 columns\n       - Medium labels (15-25 chars): 2-3 columns\n       - Long labels (> 25 chars): 1-2 columns\n       - Very long labels (> 40 chars): 1 column\n\n    2. **Dynamic `bbox_to_anchor` Positioning**\n       - 1 column: `x=0.5` (centered)\n       - 2 columns: `x=0.35` (slightly left)\n       - 3 columns: `x=0.4` (balanced)\n       - 4+ columns: `x=0.45` (nearly centered)\n\n    3. **Smart Overlap Avoidance**\n       - Use `position=\"best\"` for automatic placement inside plot\n       - Matplotlib's algorithm finds position with minimal data overlap\n       - Perfect for plots without titles (common in PRS manuscripts)\n\n    **Usage Examples:**\n    ```python\n    # Fully automatic (recommended)\n    prs_legend(ax, position=\"top-smart\")\n\n    # Manual override if needed\n    prs_legend(ax, position=\"top\", ncol=2)\n\n    # Smart inside positioning (avoids data overlap)\n    prs_legend(ax, position=\"best\")\n    ```\n\n    **Key Benefits:**\n    - \u2705 No manual `ncol` calculation needed\n    - \u2705 Optimal positioning based on label length\n    - \u2705 Consistent professional appearance\n    - \u2705 Works perfectly for no-title plots (PRS standard)\n\n    **Use Cases:** Any plot with legends, especially when label lengths vary or you want automatic optimal layout",
      "newString": "    **PRS-DataViz Smart Legend Features:**\n\n    1. **Auto-Calculates Columns** (based on label text length)\n       - Short labels (< 15 chars avg): 2-4 columns\n       - Medium labels (15-25 chars): 2-3 columns\n       - Long labels (> 25 chars): 1-2 columns\n       - Very long labels (> 40 chars): 1 column\n\n    2. **Auto-Detects Bar Charts** (applies prominent handles automatically)\n       - `markerscale=4` \u2192 4\u00d7 larger markers\n       - `handleheight=2` \u2192 Taller color boxes\n       - `handlelength=2` \u2192 Standard width\n       - Makes bar legends highly visible and professional\n\n    3. **Dynamic `bbox_to_anchor` Positioning**\n       - 1 column: `x=0.5` (centered)\n       - 2 columns: `x=0.35` (slightly left)\n       - 3 columns: `x=0.4` (balanced)\n       - 4+ columns: `x=0.45` (nearly centered)\n\n    4. **Smart Overlap Avoidance**\n       - Use `position=\"best\"` for automatic placement\n       - Matplotlib's algorithm finds position with minimal data overlap\n\n    **Font Size Standardization:**\n    ```python\n    # Method 1: Manual standardization\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Time\", fontsize=fontsize)\n    ax.set_ylabel(\"Response\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    # Method 2: Helper function\n    from prs_dataviz import set_axis_fontsize\n    set_axis_fontsize(ax, fontsize=14)\n    prs_legend(ax, position=\"top\", fontsize=14)\n    ```\n\n    **Usage Examples:**\n    ```python\n    # Fully automatic (recommended for bar charts)\n    prs_legend(ax, position=\"top-smart\")\n\n    # With standardized font size\n    prs_legend(ax, position=\"top\", fontsize=14)\n\n    # Smart inside positioning (avoids data overlap)\n    prs_legend(ax, position=\"best\")\n    ```\n\n    **Key Benefits:**\n    - \u2705 Bar charts automatically get prominent handles\n    - \u2705 No manual `ncol` calculation needed\n    - \u2705 Standardized font sizing across figure\n    - \u2705 Works perfectly for no-title plots (PRS standard)\n\n    **Use Cases:** Bar charts, stacked charts, any plot where you want automatic optimal legend layout",
      "originalFile": "# /// script\n# requires-python = \">=3.13\"\n# dependencies = [\n#     \"prs-dataviz @ git+https://github.com/Shakes-tzd/prs-dataviz.git\",\n#     \"matplotlib>=3.7\",\n#     \"numpy>=1.24\",\n#     \"pillow>=10.0\",\n#     \"marimo>=0.17.0\",\n#     \"pyzmq\",\n#     \"pandas\",\n# ]\n# ///\n\n\"\"\"\nPRS DataViz Gallery: Professional Data Visualization for Medical Research\n\nThis interactive gallery demonstrates the prs-dataviz package for creating\npublication-quality figures that meet Plastic and Reconstructive Surgery (PRS)\njournal submission requirements.\n\nDesign Philosophy:\n- Du Bois-inspired aesthetics (historical data visualization excellence)\n- Ophelia approach (Cara Thompson's accessible dataviz methodology)\n- PRS compliance (300 DPI, CMYK, professional quality)\n\nReference:\n- Cara Thompson's 10-step process: https://www.cararthompson.com/talks/on-brand-accessibility/\n- PRS Guidelines: https://journals.lww.com/plasreconsurg/\n\"\"\"\n\nimport marimo\n\n__generated_with = \"0.18.0\"\napp = marimo.App(width=\"full\")\n\n\n@app.cell\ndef _():\n    import marimo as mo\n    return (mo,)\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    # PRS DataViz: Professional Medical Data Visualization\n\n    A comprehensive design system for creating **publication-quality figures** that meet\n    [Plastic and Reconstructive Surgery (PRS)](https://journals.lww.com/plasreconsurg/)\n    journal submission requirements.\n\n    ## Design Principles\n\n    This package integrates three complementary approaches:\n\n    1. **Du Bois Aesthetic**: Historical excellence in data visualization with rich, earthy color palettes\n    2. **Ophelia Methodology**: [Cara Thompson's](https://www.cararthompson.com/talks/on-brand-accessibility/)\n       10-step process for accessible, neurodivergent-friendly visualization\n    3. **PRS Compliance**: Automatic enforcement of journal requirements (300 DPI, CMYK, proper sizing)\n\n    ### Why This Matters for Medical Research\n\n    - \u2705 **Automatic PRS compliance** - No manual DPI/CMYK conversion\n    - \u2705 **Professional medical palettes** - CMYK-safe, colorblind-friendly\n    - \u2705 **Before/after layouts** - With size validation\n    - \u2705 **Accessibility-first** - WCAG 2.1 compliant, neurodivergent-friendly\n    - \u2705 **Time-saving** - 2-3 hours saved per figure\n\n    ---\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ## \ud83d\udce6 Installation\n\n    Install directly from GitHub using either `uv` (recommended) or `pip`:\n\n    ### Quick Install\n\n    ```bash\n    # Using uv (10-100x faster)\n    uv pip install \"prs-dataviz @ git+https://github.com/Shakes-tzd/prs-dataviz.git\"\n\n    # Or using pip\n    pip install \"git+https://github.com/Shakes-tzd/prs-dataviz.git\"\n    ```\n\n    ### With Virtual Environment\n\n    ```bash\n    # Create virtual environment\n    uv venv  # or: python -m venv .venv\n    source .venv/bin/activate  # On macOS/Linux\n    # .venv\\Scripts\\activate  # On Windows\n\n    # Install package\n    uv pip install \"prs-dataviz @ git+https://github.com/Shakes-tzd/prs-dataviz.git\"\n    ```\n\n    ### For Development\n\n    ```bash\n    git clone https://github.com/Shakes-tzd/prs-dataviz.git\n    cd prs-dataviz\n    uv pip install -e \".[dev]\"\n    ```\n\n    **Prerequisites**: Python 3.11+, Git\n\n    \ud83d\udcda **Full Documentation**: [GitHub Repository](https://github.com/Shakes-tzd/prs-dataviz)\n\n    ---\n    \"\"\")\n    return\n\n\n@app.cell\ndef _():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import pandas as pd\n\n    # Import from the actual prs-dataviz package\n    from prs_dataviz import (\n        CLINICAL_BLUE,\n        CLINICAL_DATA,\n        COMPARISON,\n        STATISTICAL,\n        TISSUE_TONE,\n        add_significance_indicator,\n        apply_prs_style,\n        prs_legend,\n    )\n    return (\n        CLINICAL_BLUE,\n        CLINICAL_DATA,\n        COMPARISON,\n        STATISTICAL,\n        TISSUE_TONE,\n        add_significance_indicator,\n        apply_prs_style,\n        np,\n        pd,\n        plt,\n        prs_legend,\n    )\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ## \ud83c\udfa8 Color Palettes\n\n    All palettes are designed for medical/surgical contexts with:\n    - **CMYK-safe colors** (print-ready)\n    - **Colorblind-friendly** (tested for deuteranopia, protanopia, tritanopia)\n    - **WCAG 2.1 accessible** (proper contrast ratios)\n    - **Professional aesthetics** (muted, clinical appropriate)\n\n    ### Philosophy\n\n    Like the Ophelia package builds from anchor colors with semantic meaning, PRS DataViz\n    palettes are purpose-built for medical research contexts, balancing clinical professionalism\n    with visual accessibility.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(\n    CLINICAL_BLUE,\n    CLINICAL_DATA,\n    COMPARISON,\n    STATISTICAL,\n    TISSUE_TONE,\n    mo,\n    plt,\n):\n    # Color palette swatches\n    def create_palette_swatch(palette_dict, title):\n        fig, ax = plt.subplots(figsize=(10, 2))\n\n        colors = list(palette_dict.values())\n        labels = list(palette_dict.keys())\n        n_colors = len(colors)\n\n        # Create color swatches\n        for i, (color, label) in enumerate(zip(colors, labels)):\n            ax.add_patch(\n                plt.Rectangle(\n                    (i, 0), 1, 1, facecolor=color, edgecolor=\"#333\", linewidth=1\n                )\n            )\n            ax.text(\n                i + 0.5,\n                0.5,\n                label,\n                ha=\"center\",\n                va=\"center\",\n                fontsize=10,\n                fontweight=\"bold\",\n                color=\"white\" if i < 2 else \"#333\",\n            )\n            ax.text(\n                i + 0.5,\n                -0.3,\n                color,\n                ha=\"center\",\n                va=\"top\",\n                fontsize=9,\n                family=\"monospace\",\n                color=\"#666\",\n            )\n\n        ax.set_xlim(0, n_colors)\n        ax.set_ylim(-0.5, 1.2)\n        ax.axis(\"off\")\n        ax.set_title(title, fontsize=14, fontweight=\"bold\", pad=10, loc=\"left\")\n\n        plt.tight_layout()\n        return fig\n\n    # Create swatches for each palette\n    palette_clinical_blue = create_palette_swatch(\n        CLINICAL_BLUE, \"Clinical Blue - Professional & Trustworthy\"\n    )\n    palette_clinical_data = create_palette_swatch(\n        CLINICAL_DATA, \"Clinical Data - Statistical Visualization\"\n    )\n    palette_tissue = create_palette_swatch(\n        TISSUE_TONE, \"Tissue Tone - Medical Photography\"\n    )\n    palette_comparison = create_palette_swatch(\n        COMPARISON, \"Comparison - Before/After & Treatment\"\n    )\n    palette_statistical = create_palette_swatch(\n        STATISTICAL, \"Statistical - Significance Levels\"\n    )\n\n    mo.vstack(\n        [\n            palette_clinical_blue,\n            mo.md(\n                \"Use for: General medical data, professional contexts, trustworthy clinical presentations\"\n            ),\n            mo.md(\"---\"),\n            palette_clinical_data,\n            mo.md(\n                \"Use for: Statistical graphs, research data, multi-series comparisons\"\n            ),\n            mo.md(\"---\"),\n            palette_tissue,\n            mo.md(\n                \"Use for: Skin/tissue visualization, patient photo contexts, anatomical references\"\n            ),\n            mo.md(\"---\"),\n            palette_comparison,\n            mo.md(\n                \"Use for: Before/after surgical outcomes, treatment comparisons, control vs. experimental\"\n            ),\n            mo.md(\"---\"),\n            palette_statistical,\n            mo.md(\n                \"Use for: P-value visualization, significance indicators, hypothesis testing results\"\n            ),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ## \ud83d\udcd0 Significance Annotation Spacing\n\n    ### Automatic Positioning with Improved Spacing\n\n    The package now features **automatic bracket positioning** with optimized spacing parameters\n    for clean, professional significance indicators:\n\n    **Spacing Parameters:**\n    - **Base offset**: 5% of data range above tallest bar (67% more compact than original 15%)\n    - **Text offset**: 1% of y-axis range between bracket and p-value (67% reduction from 3%)\n    - **Text spacing**: 2% of data range for text height (compact but readable)\n    - **Stack spacing**: 8% of data range between multiple brackets\n\n    **Benefits:**\n    - \u2705 **Compact layout** - Minimal whitespace, maximum data-ink ratio\n    - \u2705 **Automatic calculation** - No manual y-position needed\n    - \u2705 **Consistent spacing** - Professional appearance across all figures\n    - \u2705 **Multiple comparisons** - Clean stacking with `add_multiple_comparisons()`\n\n    **Usage:**\n\n    ```python\n    from prs_dataviz import add_multiple_comparisons\n\n    # Automatic positioning - no manual y-coordinates needed!\n    comparisons = [\n        (2, 3, 0.025),    # Compare index 2 vs 3, p=0.025\n        (1, 3, 0.008),    # Compare index 1 vs 3, p=0.008\n        (0, 3, 0.0002),   # Compare index 0 vs 3, p=0.0002\n    ]\n    add_multiple_comparisons(ax, comparisons, x_positions)\n    ```\n\n    The function automatically calculates optimal bracket heights with 5% base clearance\n    and 8% spacing between stacked brackets.\n\n    ---\n\n    ## \ud83d\udcca Interactive Examples\n\n    Progressive complexity demonstrations following the Ophelia approach:\n    start simple, build sophistication, maintain consistency.\n\n    ### 1. Basic Statistical Bar Chart\n\n    The foundational visualization for treatment efficacy and group comparisons.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(\n    COMPARISON,\n    add_significance_indicator,\n    apply_prs_style,\n    np,\n    plt,\n    prs_legend,\n):\n    # ========================================================================\n    # Example 1: Statistical Bar Chart\n    # ========================================================================\n    def create_example1():\n        \"\"\"Create statistical bar chart with significance indicator.\"\"\"\n        apply_prs_style(cycle=\"comparison\", show_grid=True)\n\n        fig, ax = plt.subplots(figsize=(8, 5))\n\n        # Sample data: Treatment efficacy over time\n        categories = [\"Pre-operative\", \"3 Months\", \"6 Months\", \"12 Months\"]\n        control = [65, 68, 70, 72]\n        treatment = [65, 75, 82, 88]\n\n        x = np.arange(len(categories))\n        width = 0.35\n\n        # Explicit color assignment using COMPARISON palette\n        ax.bar(\n            x - width / 2,\n            control,\n            width,\n            label=\"Control\",\n            color=COMPARISON[\"Control\"],\n            alpha=0.8,\n        )\n        ax.bar(\n            x + width / 2,\n            treatment,\n            width,\n            label=\"Treatment\",\n            color=COMPARISON[\"Treatment\"],\n            alpha=0.8,\n        )\n\n        # Labels\n        ax.set_ylabel(\"Patient Satisfaction Score (%)\")\n        ax.set_xlabel(\"Follow-up Time\")\n        ax.set_title(\"Treatment Efficacy Over Time\", fontweight=\"bold\", pad=15)\n        ax.set_xticks(x)\n        ax.set_xticklabels(categories)\n        ax.set_ylim(0, 105)\n        prs_legend(ax, position=\"best\")  # Smart positioning - avoids data overlap\n        ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n        ax.set_axisbelow(True)\n\n        # Statistical significance\n        add_significance_indicator(\n            ax,\n            x=2.5,\n            y=92,\n            p_value=0.05,\n            bracket=True,\n            x_start=2.5 - width / 2,\n            x_end=2.5 + width / 2,\n        )\n\n        plt.tight_layout()\n        return fig\n\n    example1_fig = create_example1()\n    return (example1_fig,)\n\n\n@app.cell\ndef _(example1_fig, mo):\n    mo.vstack(\n        [\n            example1_fig,\n            mo.md(\"\"\"\n        **PRS-DataViz Functions Used:**\n\n        1. **`apply_prs_style(cycle=\"comparison\", show_grid=True)`**\n           - Sets global styling with comparison color palette\n           - Typography: 10pt base (accessible), 12pt titles\n           - Professional grid for data reading\n\n        2. **`COMPARISON[\"Control\"]` & `COMPARISON[\"Treatment\"]`**\n           - CMYK-safe colors: #7A8A99 (steel blue), #9B7357 (warm brown)\n           - Colorblind-friendly palette\n           - Explicit color assignment (not relying on cycle)\n\n        3. **`add_significance_indicator(ax, x, y, p_value, bracket=True, ...)`**\n           - PRS-compliant statistical annotation\n           - **Improved spacing**: 5% base offset, 1% text offset (67% more compact)\n           - Automatic accessible typography (10pt p-value, 16pt symbol)\n           - Bracket for clear group comparison\n           - For multiple comparisons, use `add_multiple_comparisons()` with automatic positioning\n\n        **Result:** Publication-ready figure meeting PRS requirements (300 DPI, CMYK, 5\" width)\n        \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 2. Line Graph with Confidence Intervals\n\n    Time series data with uncertainty visualization - essential for longitudinal studies.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(COMPARISON, apply_prs_style, np, plt, prs_legend):\n    # Example 2: Line graph with confidence intervals\n    def create_example2():\n        \"\"\"Create line graph with confidence intervals.\"\"\"\n        apply_prs_style(cycle=\"comparison\")\n\n        fig, ax = plt.subplots(figsize=(8, 5))\n\n        months = np.array([0, 1, 3, 6, 12, 18, 24])\n        treatment_mean = np.array([50, 62, 72, 80, 85, 87, 88])\n        treatment_std = np.array([8, 7, 6, 5, 4, 4, 4])\n        control_mean = np.array([50, 54, 58, 62, 65, 67, 68])\n        control_std = np.array([8, 8, 7, 7, 6, 6, 6])\n\n        # Plot lines with comparison palette colors\n        ax.plot(\n            months,\n            treatment_mean,\n            marker=\"o\",\n            linewidth=2.5,\n            label=\"Treatment\",\n            markersize=7,\n            color=COMPARISON[\"Treatment\"],\n        )\n        ax.plot(\n            months,\n            control_mean,\n            marker=\"s\",\n            linewidth=2.5,\n            label=\"Control\",\n            markersize=7,\n            color=COMPARISON[\"Control\"],\n        )\n\n        # Add confidence intervals\n        ax.fill_between(\n            months,\n            treatment_mean - treatment_std,\n            treatment_mean + treatment_std,\n            alpha=0.2,\n            color=COMPARISON[\"Treatment\"],\n        )\n        ax.fill_between(\n            months,\n            control_mean - control_std,\n            control_mean + control_std,\n            alpha=0.2,\n            color=COMPARISON[\"Control\"],\n        )\n\n        ax.set_xlabel(\"Time Since Surgery (months)\")\n        ax.set_ylabel(\"Recovery Score\")\n        ax.set_title(\"Long-term Recovery Trajectories\", fontweight=\"bold\", pad=15)\n        prs_legend(ax, position=\"lower right\")\n        ax.set_ylim(35, 100)\n        ax.grid(True, alpha=0.3, linestyle=\"--\")\n        ax.set_axisbelow(True)\n\n        plt.tight_layout()\n        return fig\n\n    example2_fig = create_example2()\n    return (example2_fig,)\n\n\n@app.cell\ndef _(example2_fig, mo):\n    mo.vstack(\n        [\n            example2_fig,\n            mo.md(\"\"\"\n        **Key Features:**\n        - Smooth lines with distinct markers\n        - Confidence intervals (shaded regions)\n        - Clear temporal progression\n        - Professional grid for reading values\n        - **Suitable for**: Healing progression, follow-up studies, longitudinal data\n        \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 3. Before/After Comparison\n\n    The cornerstone of surgical outcomes research - properly sized and styled.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(COMPARISON, apply_prs_style, np, plt, prs_legend):\n    # Example 3: Before/After scatter comparison\n    def create_example3():\n        \"\"\"Create before/after scatter comparison.\"\"\"\n        apply_prs_style(cycle=\"comparison\")\n\n        fig, (ax_before, ax_after) = plt.subplots(1, 2, figsize=(12, 5))\n\n        # Generate mock measurement data\n        np.random.seed(42)\n        n_patients = 30\n        before_values = np.random.normal(45, 10, n_patients)\n        after_values = before_values + np.random.normal(25, 5, n_patients)\n\n        # Before\n        ax_before.scatter(\n            range(n_patients),\n            before_values,\n            s=60,\n            alpha=0.7,\n            edgecolors=\"black\",\n            linewidth=0.5,\n            color=COMPARISON[\"Before\"],\n        )\n        ax_before.axhline(\n            y=np.mean(before_values),\n            color=\"#333\",\n            linestyle=\"--\",\n            linewidth=1.5,\n            alpha=0.7,\n            label=f\"Mean: {np.mean(before_values):.1f}\",\n        )\n        ax_before.set_ylabel(\"Measurement (mm)\")\n        ax_before.set_xlabel(\"Patient ID\")\n        ax_before.set_title(\"Preoperative\", fontweight=\"bold\", pad=10)\n        ax_before.set_ylim(20, 90)\n        prs_legend(ax_before, position=\"upper right\")\n        ax_before.grid(True, alpha=0.3, axis=\"y\")\n\n        # After\n        ax_after.scatter(\n            range(n_patients),\n            after_values,\n            s=60,\n            alpha=0.7,\n            edgecolors=\"black\",\n            linewidth=0.5,\n            color=COMPARISON[\"After\"],\n        )\n        ax_after.axhline(\n            y=np.mean(after_values),\n            color=\"#333\",\n            linestyle=\"--\",\n            linewidth=1.5,\n            alpha=0.7,\n            label=f\"Mean: {np.mean(after_values):.1f}\",\n        )\n        ax_after.set_ylabel(\"Measurement (mm)\")\n        ax_after.set_xlabel(\"Patient ID\")\n        ax_after.set_title(\"6 Months Postoperative\", fontweight=\"bold\", pad=10)\n        ax_after.set_ylim(20, 90)\n        prs_legend(ax_after, position=\"upper right\")\n        ax_after.grid(True, alpha=0.3, axis=\"y\")\n\n        plt.tight_layout()\n        return fig\n\n    example3_fig = create_example3()\n    return (example3_fig,)\n\n\n@app.cell\ndef _(example3_fig, mo):\n    mo.vstack(\n        [\n            example3_fig,\n            mo.md(\"\"\"\n        **Key Features:**\n        - Comparison color palette (warm gray vs. clinical teal)\n        - Identical y-axis scales (PRS requirement)\n        - Mean lines with values\n        - Individual data points visible\n        - **PRS Requirement**: When using patient photos, ensure identical size, lighting, and position\n        \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 4. Box Plot Distribution\n\n    Showing variability and central tendency across treatment groups.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(CLINICAL_DATA, add_significance_indicator, apply_prs_style, np, plt):\n    # Example 4: Box plots\n    def create_example4():\n        \"\"\"Create box plot comparison with significance.\"\"\"\n        apply_prs_style(cycle=\"clinical\")\n\n        fig, ax = plt.subplots(figsize=(8, 6))\n\n        # Generate sample data\n        np.random.seed(123)\n        group_a = np.random.normal(68, 12, 50)\n        group_b = np.random.normal(78, 10, 50)\n        group_c = np.random.normal(85, 8, 50)\n\n        data_groups = [group_a, group_b, group_c]\n        positions = [1, 2, 3]\n\n        bp = ax.boxplot(\n            data_groups,\n            positions=positions,\n            widths=0.6,\n            patch_artist=True,\n            showfliers=True,\n            boxprops={\"linewidth\": 1.5},\n            medianprops={\"color\": \"black\", \"linewidth\": 2},\n            whiskerprops={\"linewidth\": 1.5},\n            capprops={\"linewidth\": 1.5},\n        )\n\n        # Color boxes\n        colors = [\n            CLINICAL_DATA[\"Primary\"],\n            CLINICAL_DATA[\"Secondary\"],\n            CLINICAL_DATA[\"Tertiary\"],\n        ]\n        for patch, color in zip(bp[\"boxes\"], colors):\n            patch.set_facecolor(color)\n            patch.set_alpha(0.7)\n\n        ax.set_xlabel(\"Treatment Group\")\n        ax.set_ylabel(\"Outcome Score\")\n        ax.set_title(\"Treatment Group Comparison\", fontweight=\"bold\", pad=15)\n        ax.set_xticks(positions)\n        ax.set_xticklabels([\"Group A\\n(n=50)\", \"Group B\\n(n=50)\", \"Group C\\n(n=50)\"])\n        ax.set_ylim(35, 110)\n        ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n        ax.set_axisbelow(True)\n\n        # Statistical significance\n        add_significance_indicator(\n            ax,\n            x=1.5,\n            y=100,\n            p_value=0.01,\n            symbol=\"**\",\n            bracket=True,\n            x_start=1,\n            x_end=2,\n        )\n\n        plt.tight_layout()\n        return fig\n\n    example4_fig = create_example4()\n    return (example4_fig,)\n\n\n@app.cell\ndef _(example4_fig, mo):\n    mo.vstack(\n        [\n            example4_fig,\n            mo.md(\"\"\"\n        **PRS-DataViz Functions Used:**\n\n        1. **`apply_prs_style(cycle=\"clinical\")`**\n           - Clinical data palette (muted professional colors)\n           - Automatic accessible typography\n\n        2. **`CLINICAL_DATA[\"Primary\"]`, `[\"Secondary\"]`, `[\"Tertiary\"]`**\n           - Explicit color assignment to box plots\n           - CMYK-safe, colorblind-friendly\n\n        3. **`add_significance_indicator(ax, x, y, p_value, symbol=\"**\", bracket=True, ...)`**\n           - Bracket-style comparison between Group A and Group B\n           - Symbol \"**\" for p < 0.01 (highly significant)\n           - Automatic accessible typography and positioning\n\n        **Box Plot Interpretation:** Box = IQR (25th-75th percentile), Line = Median, Whiskers = 1.5\u00d7IQR\n        \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ## \ud83c\udfaf PRS Compliance Features\n\n    ### Automatic Enforcement\n\n    The package automatically ensures your figures meet all PRS requirements:\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(mo):\n    # Create compliance table\n    compliance_data = {\n        \"Requirement\": [\n            \"Resolution\",\n            \"Color Mode\",\n            \"Minimum Width\",\n            \"File Formats\",\n            \"Multi-Panel\",\n            \"Before/After Sizing\",\n            \"Professional Quality\",\n        ],\n        \"PRS Standard\": [\n            \"300 DPI minimum\",\n            \"CMYK for print\",\n            '3.25\" (photos) / 5\" (graphs)',\n            \"TIFF, PNG, JPEG, PDF, EPS\",\n            \"Separate files (1a, 1b, 1c)\",\n            \"Identical dimensions\",\n            \"High quality, proper lighting\",\n        ],\n        \"How Package Handles It\": [\n            \"`save_prs_figure(dpi=300)` - automatic\",\n            \"`save_prs_figure(cmyk=True)` - automatic\",\n            \"Validated automatically\",\n            \"All supported\",\n            \"`save_multi_panel_figure()` creates separate files\",\n            \"`create_before_after_figure()` validates sizing\",\n            \"Professional styling defaults\",\n        ],\n        \"Status\": [\n            \"\u2705 Automatic\",\n            \"\u2705 Automatic\",\n            \"\u2705 Validated\",\n            \"\u2705 Supported\",\n            \"\u2705 Automatic\",\n            \"\u2705 Validated\",\n            \"\u26a0\ufe0f User ensures quality\",\n        ],\n    }\n\n    compliance_df = mo.ui.table(\n        compliance_data, selection=None, label=\"PRS Compliance Matrix\"\n    )\n\n    mo.vstack(\n        [\n            mo.md(\"### PRS Requirements Compliance Matrix\"),\n            compliance_df,\n            mo.md(\"\"\"\n        **Legend:**\n        - \u2705 **Automatic**: Package enforces automatically\n        - \u26a0\ufe0f **User**: User responsible (package provides guidance)\n        \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### Code Example: Saving PRS-Compliant Figure\n\n    ```python\n    from prs_dataviz import apply_prs_style, save_prs_figure\n    import matplotlib.pyplot as plt\n\n    # 1. Apply styling\n    apply_prs_style(cycle=\"clinical\", show_grid=True)\n\n    # 2. Create figure\n    fig, ax = plt.subplots(figsize=(5, 4))\n    ax.bar(['A', 'B', 'C'], [75, 82, 88])\n    ax.set_ylabel('Outcome Score (%)')\n\n    # 3. Save PRS-compliant\n    save_prs_figure(\n        fig,\n        \"figure1.tiff\",\n        dpi=300,              # PRS minimum\n        width_inches=5.0,     # 5\" for graphs, 3.25\" for photos\n        cmyk=True             # Print-ready\n    )\n\n    # 4. Validate before submission\n    from prs_dataviz import validate_figure_file\n    results = validate_figure_file(\"figure1.tiff\")\n    print(\"\u2713 Valid!\" if results['valid'] else \"Issues:\", results['issues'])\n    ```\n\n    **Result**: A TIFF file meeting all PRS requirements, ready for journal submission.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ## \u267f Accessibility Features\n\n    Following [Cara Thompson's 10-step methodology](https://www.cararthompson.com/talks/on-brand-accessibility/):\n\n    ### 1. Colorblind-Friendly Palettes\n\n    All palettes tested for:\n    - **Deuteranopia** (most common, red-green)\n    - **Protanopia** (red-green)\n    - **Tritanopia** (blue-yellow)\n\n    ### 2. WCAG 2.1 Contrast Compliance\n\n    - **Text**: 4.5:1 minimum contrast ratio\n    - **Graphics**: 3:1 minimum contrast ratio\n    - **Large text**: 3:1 minimum contrast ratio\n\n    ### 3. Neurodivergent-Friendly Design\n\n    - **Muted colors** reduce sensory overwhelm\n    - **Clear hierarchy** aids comprehension\n    - **Consistent spacing** reduces cognitive load\n    - **Professional fonts** optimize readability\n\n    ### 4. Universal Design\n\n    - **High contrast** for low vision\n    - **Clear labels** for screen readers\n    - **Alternative text** support\n    - **Semantic color use** (not color-only information)\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ## \ud83d\udce6 Package Usage\n\n    ### Installation\n\n    ```bash\n    # Using uv (recommended - 10-100x faster)\n    uv pip install -e .\n\n    # Or using pip\n    pip install -e .\n    ```\n\n    ### Quick Start\n\n    ```python\n    from prs_dataviz import (\n        apply_prs_style,\n        save_prs_figure,\n        create_before_after_figure,\n        validate_figure_file,\n    )\n\n    # Apply professional medical styling\n    apply_prs_style(cycle=\"clinical\")\n\n    # Create your figure\n    fig, ax = plt.subplots()\n    # ... your plotting code ...\n\n    # Save PRS-compliant\n    save_prs_figure(fig, \"figure1.tiff\", dpi=300, width_inches=5.0, cmyk=True)\n\n    # Validate before submission\n    results = validate_figure_file(\"figure1.tiff\")\n    ```\n\n    ### Color Palette Selection\n\n    ```python\n    # For statistical data\n    apply_prs_style(cycle=\"clinical\")\n\n    # For before/after comparisons\n    apply_prs_style(cycle=\"comparison\")\n\n    # For general multi-category data\n    apply_prs_style(cycle=\"default\")\n    ```\n\n    ### Multi-Panel Figures (PRS Requirement)\n\n    ```python\n    from prs_dataviz import save_multi_panel_figure\n\n    # Create panels\n    fig_a, ax_a = plt.subplots()\n    # ... plot panel a ...\n\n    fig_b, ax_b = plt.subplots()\n    # ... plot panel b ...\n\n    # Save as separate files (PRS requirement)\n    save_multi_panel_figure(\n        {\"a\": fig_a, \"b\": fig_b},\n        \"Figure1\",  # Creates Figure1a.tiff, Figure1b.tiff\n        dpi=300,\n        width_inches=3.5\n    )\n    ```\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 5. Demographic Stacked Bar Chart\n\n    Professional horizontal stacked bar charts for demographic and clinical characteristics analysis.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(CLINICAL_DATA, apply_prs_style, pd, plt):\n    from matplotlib.ticker import FuncFormatter\n\n    # Example 5: Demographic Stacked Bar Chart\n    def create_example5():\n        \"\"\"Create demographic stacked bar chart.\"\"\"\n        apply_prs_style(cycle=\"clinical\")\n\n        # Sample demographic data\n        categories = [\n            \"Sex\",\n            \"Race\",\n            \"Cleft Type\",\n            \"Syndromic Status\",\n            \"English Proficiency\",\n            \"Prenatal Diagnosis\",\n            \"Adoption Status\",\n            \"Migrant Status\",\n        ]\n\n        data = {\n            \"Male\": [55, 0, 0, 0, 0, 0, 0, 0],\n            \"Female\": [45, 0, 0, 0, 0, 0, 0, 0],\n            \"White\": [0, 42, 0, 0, 0, 0, 0, 0],\n            \"Non-White\": [0, 58, 0, 0, 0, 0, 0, 0],\n            \"CL/P\": [0, 0, 65, 0, 0, 0, 0, 0],\n            \"CP\": [0, 0, 35, 0, 0, 0, 0, 0],\n            \"Syndromic\": [0, 0, 0, 18, 0, 0, 0, 0],\n            \"Non-syndromic\": [0, 0, 0, 82, 0, 0, 0, 0],\n            \"Yes\": [0, 0, 0, 0, 88, 12, 8, 4],\n            \"No\": [0, 0, 0, 0, 12, 88, 92, 96],\n        }\n\n        df = pd.DataFrame(data, index=categories)\n\n        fig, ax = plt.subplots(figsize=(14, 8))\n\n        # Define colors\n        color_map = {\n            \"Male\": CLINICAL_DATA[\"Primary\"],\n            \"Female\": CLINICAL_DATA[\"Secondary\"],\n            \"White\": CLINICAL_DATA[\"Primary\"],\n            \"Non-White\": CLINICAL_DATA[\"Secondary\"],\n            \"CL/P\": CLINICAL_DATA[\"Primary\"],\n            \"CP\": CLINICAL_DATA[\"Secondary\"],\n            \"Syndromic\": CLINICAL_DATA[\"Primary\"],\n            \"Non-syndromic\": CLINICAL_DATA[\"Secondary\"],\n            \"Yes\": CLINICAL_DATA[\"Primary\"],\n            \"No\": CLINICAL_DATA[\"Secondary\"],\n        }\n\n        # Plot\n        df.plot(\n            kind=\"barh\",\n            stacked=True,\n            color=[color_map[col] for col in df.columns],\n            ax=ax,\n            width=0.7,\n            edgecolor=\"none\",\n        )\n\n        # Styling\n        ax.spines[\"left\"].set_visible(True)\n        ax.spines[\"bottom\"].set_linewidth(2)\n        ax.spines[\"bottom\"].set_color(\"#333\")\n        ax.set_xlabel(\"Percentage of Patients (%)\", fontsize=14, fontweight=\"bold\")\n        ax.set_ylabel(\"\")\n        ax.set_xlim(0, 100)\n        ax.set_xticks([0, 50, 100])\n        ax.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{x:.0f}%\"))\n        ax.tick_params(axis=\"both\", labelsize=12, colors=\"#333\")\n\n        for label in ax.get_yticklabels():\n            label.set_fontweight(\"bold\")\n\n        # Add value annotations\n        for i, (_, row) in enumerate(df.iterrows()):\n            x_offset = 0\n            for col in df.columns:\n                val = row[col]\n                if val > 0:\n                    text_color = \"#333\" if val < 15 else \"white\"\n                    x_pos = x_offset + val + 3 if val < 15 else x_offset + val / 2\n                    ax.text(\n                        x_pos,\n                        i,\n                        f\"{col}\\n{val:.0f}%\",\n                        va=\"center\",\n                        ha=\"center\",\n                        color=text_color,\n                        fontsize=11,\n                        fontweight=\"bold\",\n                    )\n                    x_offset += val\n\n        ax.legend().set_visible(False)\n        ax.grid(False)\n        plt.title(\n            \"Patient Demographics and Clinical Characteristics\",\n            fontsize=16,\n            fontweight=\"bold\",\n            pad=15,\n        )\n        plt.tight_layout()\n        return fig\n\n    example5_fig = create_example5()\n    return (example5_fig,)\n\n\n@app.cell\ndef _(example5_fig, mo):\n    mo.vstack(\n        [\n            example5_fig,\n            mo.md(\"\"\"\n    **PRS-DataViz Functions Used:**\n\n    1. **`apply_prs_style(cycle=\"clinical\")`**\n       - Clinical data palette for professional medical contexts\n       - Clean typography and spacing\n\n    2. **`CLINICAL_DATA[\"Primary\"]` & `CLINICAL_DATA[\"Secondary\"]`**\n       - CMYK-safe color pairs for binary comparisons\n       - Colorblind-friendly palette\n       - Professional medical aesthetics\n\n    3. **Inline Annotations**\n       - Direct labeling reduces cognitive load\n       - Smart positioning (inside for large segments, outside for small)\n       - High contrast text for readability\n\n    **Use Cases:** Demographic analysis, clinical characteristics, categorical distributions\n    \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 6. Multi-Panel Grouped Bar Charts\n\n    Comparing outcomes across patient subgroups with professional grouped bar charts.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(CLINICAL_DATA, COMPARISON, apply_prs_style, np, plt, prs_legend):\n    # Example 6: Multi-Panel Grouped Bar Charts\n    def create_example6():\n        \"\"\"Create multi-panel grouped bar charts for outcome comparison.\"\"\"\n        apply_prs_style(cycle=\"comparison\")\n\n        # Define categories and data\n        categories = [\n            \"30 Day\\nComplications\",\n            \"Complications\\nBefore Discharge\",\n            \"Growth\\nDelay\",\n            \"Revision\\nPerformed\",\n            \"Speech\\nTherapy\",\n            \"Velopharyngeal\\nInsufficiency\",\n        ]\n\n        # Sample data\n        non_syndromic_adopted = [0, 3.12, 6.25, 31.25, 78.12, 15.62]\n        syndromic_adopted = [0, 0, 0, 0, 0, 0]\n        non_syndromic_not_adopted = [2, 3, 5, 1, 25, 8]\n        syndromic_not_adopted = [3, 4, 20, 2, 30, 12]\n\n        # Create figure with two subplots\n        fig, (ax_top, ax_bottom) = plt.subplots(2, 1, figsize=(14, 10))\n\n        # Colors\n        colors = {\n            \"Non-syndromic\": CLINICAL_DATA[\"Primary\"],\n            \"Syndromic\": COMPARISON[\"Treatment\"],\n        }\n\n        x_pos = np.arange(len(categories))\n        width = 0.35\n\n        # Helper function to plot grouped bars\n        def plot_grouped_bars(ax, non_syn_data, syn_data, ylabel):\n            for i, (group_type, data) in enumerate(\n                [(\"Non-syndromic\", non_syn_data), (\"Syndromic\", syn_data)]\n            ):\n                ax.bar(\n                    x_pos + i * width - width / 2,\n                    data,\n                    width,\n                    label=group_type,\n                    color=colors[group_type],\n                    alpha=0.9,\n                    edgecolor=\"none\",\n                )\n                # Annotations\n                for j, val in enumerate(data):\n                    if val > 0:\n                        ax.text(\n                            x_pos[j] + i * width - width / 2,\n                            val + 1.5,\n                            f\"{val:.0f}\",\n                            ha=\"center\",\n                            va=\"bottom\",\n                            fontsize=12,\n                            fontweight=\"bold\",\n                            color=\"#333\",\n                        )\n\n            ax.set_ylabel(ylabel, fontsize=14, fontweight=\"bold\")\n            ax.set_xticks(x_pos)\n            ax.set_xticklabels(categories, fontsize=11, color=\"#333\")\n            ax.tick_params(axis=\"y\", labelsize=12, colors=\"#333\")\n            ax.spines[\"top\"].set_visible(False)\n            ax.spines[\"right\"].set_visible(False)\n            ax.grid(False)\n            for label in ax.get_yticklabels():\n                label.set_fontweight(\"bold\")\n\n        # Adopted subplot\n        plot_grouped_bars(\n            ax_top,\n            non_syndromic_adopted,\n            syndromic_adopted,\n            \"Adopted\\nNumber of Patients\",\n        )\n        prs_legend(ax_top, position=\"top\", ncol=2)\n\n        # Not adopted subplot\n        plot_grouped_bars(\n            ax_bottom,\n            non_syndromic_not_adopted,\n            syndromic_not_adopted,\n            \"Not Adopted\\nNumber of Patients\",\n        )\n        ax_bottom.set_xlabel(\"\")\n        # No legend on bottom subplot (shown on top)\n\n        plt.suptitle(\n            \"Clinical Outcomes by Adoption Status and Syndrome\",\n            fontsize=16,\n            fontweight=\"bold\",\n            y=0.995,\n        )\n        plt.tight_layout()\n        return fig\n\n    example6_fig = create_example6()\n    return (example6_fig,)\n\n\n@app.cell\ndef _(example6_fig, mo):\n    mo.vstack(\n        [\n            example6_fig,\n            mo.md(\"\"\"\n    **PRS-DataViz Functions Used:**\n\n    1. **`apply_prs_style(cycle=\"comparison\")`**\n       - Comparison palette for contrasting groups\n       - Professional subplot coordination\n\n    2. **Multi-Panel Layout**\n       - Consistent styling across subplots\n       - Shared x-axis for direct comparison\n       - Professional spacing with `tight_layout()`\n\n    3. **Grouped Bar Charts**\n       - CLINICAL_DATA and COMPARISON palettes\n       - Direct value annotations for clarity\n       - Clean, minimal design\n\n    **Key Features:**\n    - Synchronized x-axes for direct comparison\n    - Inline value labels reduce eye movement\n    - Professional color coordination across panels\n\n    **Use Cases:** Subgroup analysis, multi-cohort comparisons, stratified outcomes\n    \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 7. Categorical Stacked Bar Chart\n\n    Clean stacked bar charts for multi-category outcome analysis.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(CLINICAL_DATA, COMPARISON, apply_prs_style, pd, plt, prs_legend):\n    # Example 7: Categorical Stacked Bar Chart\n    def create_example7():\n        \"\"\"Create categorical stacked bar chart.\"\"\"\n        apply_prs_style(cycle=\"clinical\")\n\n        # Sample data\n        categories = [\"Growth Delay\", \"Speech Therapy\", \"Prenatal Diagnosis\", \"Adopted\"]\n\n        data = {\n            \"Non-syndromic: No\": [82, 15, 90, 95],\n            \"Non-syndromic: Yes\": [18, 85, 10, 5],\n            \"Syndromic: No\": [60, 50, 85, 100],\n            \"Syndromic: Yes\": [40, 50, 15, 0],\n        }\n\n        df = pd.DataFrame(data, index=categories)\n\n        fig, ax = plt.subplots(figsize=(14, 8))\n\n        # Define colors\n        colors = [\n            COMPARISON[\"Treatment\"],\n            CLINICAL_DATA[\"Primary\"],\n            CLINICAL_DATA[\"Secondary\"],\n            CLINICAL_DATA[\"Tertiary\"],\n        ]\n\n        # Plot\n        df.plot(\n            kind=\"barh\", stacked=True, color=colors, ax=ax, width=0.7, edgecolor=\"none\"\n        )\n\n        # Styling\n        ax.set_xlabel(\"\")\n        ax.set_ylabel(\"\")\n        ax.tick_params(axis=\"both\", labelsize=14, colors=\"#333\")\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.spines[\"bottom\"].set_visible(False)\n\n        for label in ax.get_yticklabels():\n            label.set_fontweight(\"bold\")\n\n        # Add value labels\n        for container in ax.containers:\n            labels = [f\"{int(val)}\" if val > 0 else \"\" for val in container.datavalues]\n            ax.bar_label(\n                container,\n                labels=labels,\n                label_type=\"center\",\n                color=\"white\",\n                fontsize=14,\n                fontweight=\"bold\",\n            )\n\n        # Professional top legend with smart positioning\n        prs_legend(ax, position=\"top\", ncol=2)\n\n        ax.grid(False)\n        # plt.title(\n        #     \"Clinical Outcomes by Syndrome Status\",\n        #     fontsize=16,\n        #     fontweight=\"bold\",\n        #     pad=20,\n        # )\n        plt.tight_layout()\n        return fig\n\n    example7_fig = create_example7()\n    return (example7_fig,)\n\n\n@app.cell\ndef _(example7_fig, mo):\n    mo.vstack(\n        [\n            example7_fig,\n            mo.md(\"\"\"\n    **PRS-DataViz Functions Used:**\n\n    1. **`apply_prs_style(cycle=\"clinical\")`**\n       - Professional clinical data styling\n       - Clean, minimal aesthetic\n\n    2. **CLINICAL_DATA & COMPARISON Palettes**\n       - Multi-category color coordination\n       - CMYK-safe, colorblind-friendly\n       - Semantic color use (treatment colors for outcomes)\n\n    3. **Automatic Value Labels**\n       - `ax.bar_label()` for clean inline annotation\n       - White text on colored backgrounds for contrast\n       - Only show non-zero values\n\n    **Key Features:**\n    - Stacked percentages show full distribution\n    - Direct labeling eliminates need for legend lookups\n    - Professional color coordination across categories\n\n    **Use Cases:** Multi-category outcomes, stratified analysis, percentage distributions\n    \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ### 8. Smart Legend Positioning\n\n    Automatic column calculation and intelligent positioning for professional legends.\n    \"\"\")\n    return\n\n\n@app.cell\ndef _(CLINICAL_DATA, apply_prs_style, pd, plt, prs_legend):\n    # Example 8: Smart Legend with Auto-Column Calculation\n    def create_example8():\n        \"\"\"Create smart legend example with auto-calculated columns.\"\"\"\n        apply_prs_style(cycle=\"clinical\")\n\n        # Sample data with varying label lengths\n        categories = [\"Growth Delay\", \"Speech Therapy\", \"Prenatal Diagnosis\", \"Adopted\"]\n\n        data_short = {\n            \"Non-syndromic: No\": [82, 15, 90, 95],\n            \"Non-syndromic: Yes\": [18, 85, 10, 5],\n            \"Syndromic: No\": [60, 50, 85, 100],\n            \"Syndromic: Yes\": [40, 50, 15, 0],\n        }\n\n        df = pd.DataFrame(data_short, index=categories)\n\n        fig, ax = plt.subplots(figsize=(14, 8))\n\n        # Define colors\n        colors = [\n            CLINICAL_DATA[\"Primary\"],\n            CLINICAL_DATA[\"Secondary\"],\n            CLINICAL_DATA[\"Tertiary\"],\n            CLINICAL_DATA[\"Accent\"],\n        ]\n\n        # Plot\n        df.plot(\n            kind=\"barh\",\n            stacked=True,\n            color=colors,\n            ax=ax,\n            width=0.7,\n            edgecolor=\"none\",\n        )\n\n        # Styling\n        ax.set_xlabel(\"\")\n        ax.set_ylabel(\"\")\n        ax.tick_params(axis=\"both\", labelsize=14, colors=\"#333\")\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.spines[\"bottom\"].set_visible(False)\n\n        for label in ax.get_yticklabels():\n            label.set_fontweight(\"bold\")\n\n        # Add value labels\n        for container in ax.containers:\n            labels = [f\"{int(val)}\" if val > 0 else \"\" for val in container.datavalues]\n            ax.bar_label(\n                container,\n                labels=labels,\n                label_type=\"center\",\n                color=\"white\",\n                fontsize=14,\n                fontweight=\"bold\",\n            )\n\n        ax.grid(False)\n\n        # SMART LEGEND: Auto-calculates optimal columns based on label length\n        # For these short labels, it will automatically choose 2 columns\n        # and position at bbox_to_anchor=(0.35, 1.12)\n        prs_legend(ax, position=\"top-smart\")\n\n        plt.tight_layout()\n        return fig\n\n    example8_fig = create_example8()\n    return (example8_fig,)\n\n\n@app.cell\ndef _(example8_fig, mo):\n    mo.vstack(\n        [\n            example8_fig,\n            mo.md(\"\"\"\n    **PRS-DataViz Smart Legend Features:**\n\n    1. **`prs_legend(ax, position=\"top-smart\")`**\n       - **Auto-calculates columns** based on label text length\n       - Short labels (< 15 chars avg): 2-4 columns\n       - Medium labels (15-25 chars): 2-3 columns\n       - Long labels (> 25 chars): 1-2 columns\n       - Very long labels (> 40 chars): 1 column\n\n    2. **Dynamic `bbox_to_anchor` Positioning**\n       - 1 column: `x=0.5` (centered)\n       - 2 columns: `x=0.35` (slightly left)\n       - 3 columns: `x=0.4` (balanced)\n       - 4+ columns: `x=0.45` (nearly centered)\n\n    3. **Smart Overlap Avoidance**\n       - Use `position=\"best\"` for automatic placement inside plot\n       - Matplotlib's algorithm finds position with minimal data overlap\n       - Perfect for plots without titles (common in PRS manuscripts)\n\n    **Usage Examples:**\n    ```python\n    # Fully automatic (recommended)\n    prs_legend(ax, position=\"top-smart\")\n\n    # Manual override if needed\n    prs_legend(ax, position=\"top\", ncol=2)\n\n    # Smart inside positioning (avoids data overlap)\n    prs_legend(ax, position=\"best\")\n    ```\n\n    **Key Benefits:**\n    - \u2705 No manual `ncol` calculation needed\n    - \u2705 Optimal positioning based on label length\n    - \u2705 Consistent professional appearance\n    - \u2705 Works perfectly for no-title plots (PRS standard)\n\n    **Use Cases:** Any plot with legends, especially when label lengths vary or you want automatic optimal layout\n    \"\"\"),\n        ]\n    )\n    return\n\n\n@app.cell\ndef _(mo):\n    mo.md(r\"\"\"\n    ---\n\n    ## \ud83d\udcda Resources\n\n    ### Package Documentation\n    - **Quick Start**: `QUICK_START.md` - Copy-paste templates\n    - **Handoff Document**: `HANDOFF_DOCUMENT.md` - Complete usage guide\n    - **README**: `README.md` - Comprehensive reference\n    - **Examples**: `example.py` - Working code\n\n    ### External References\n    - [PRS Author Guidelines](https://journals.lww.com/plasreconsurg/pages/informationforauthors.aspx)\n    - [PRS Digital Artwork Guide](http://links.lww.com/ES/A42)\n    - [Cara Thompson: On-Brand Accessibility](https://www.cararthompson.com/talks/on-brand-accessibility/)\n    - [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)\n\n    ### Design System Credits\n    - **Methodology**: Cara Thompson's 10-step accessible dataviz process\n    - **Aesthetic**: Du Bois-inspired color palettes and styling\n    - **Approach**: Ophelia package's progressive documentation model\n\n    ---\n\n    ## \ud83c\udf89 Summary\n\n    This package streamlines the journey from data to publication-quality figures while ensuring:\n\n    - \u2705 **Automatic PRS compliance** (300 DPI, CMYK, proper sizing)\n    - \u2705 **Professional medical aesthetics** (clinical color palettes)\n    - \u2705 **Accessibility** (colorblind-friendly, WCAG 2.1 compliant)\n    - \u2705 **Time savings** (2-3 hours per figure)\n    - \u2705 **Reproducibility** (code-based figures)\n\n    **Start creating professional medical visualizations today!**\n\n    ```bash\n    uv run python example.py  # See it in action\n    ```\n    \"\"\")\n    return\n\n\nif __name__ == \"__main__\":\n    app.run()\n",
      "structuredPatch": [
        {
          "oldStart": 1488,
          "oldLines": 43,
          "newStart": 1488,
          "newLines": 62,
          "lines": [
            "             mo.md(\"\"\"",
            "     **PRS-DataViz Smart Legend Features:**",
            " ",
            "-    1. **`prs_legend(ax, position=\"top-smart\")`**",
            "-       - **Auto-calculates columns** based on label text length",
            "+    1. **Auto-Calculates Columns** (based on label text length)",
            "        - Short labels (< 15 chars avg): 2-4 columns",
            "        - Medium labels (15-25 chars): 2-3 columns",
            "        - Long labels (> 25 chars): 1-2 columns",
            "        - Very long labels (> 40 chars): 1 column",
            " ",
            "-    2. **Dynamic `bbox_to_anchor` Positioning**",
            "+    2. **Auto-Detects Bar Charts** (applies prominent handles automatically)",
            "+       - `markerscale=4` \u2192 4\u00d7 larger markers",
            "+       - `handleheight=2` \u2192 Taller color boxes",
            "+       - `handlelength=2` \u2192 Standard width",
            "+       - Makes bar legends highly visible and professional",
            "+",
            "+    3. **Dynamic `bbox_to_anchor` Positioning**",
            "        - 1 column: `x=0.5` (centered)",
            "        - 2 columns: `x=0.35` (slightly left)",
            "        - 3 columns: `x=0.4` (balanced)",
            "        - 4+ columns: `x=0.45` (nearly centered)",
            " ",
            "-    3. **Smart Overlap Avoidance**",
            "-       - Use `position=\"best\"` for automatic placement inside plot",
            "+    4. **Smart Overlap Avoidance**",
            "+       - Use `position=\"best\"` for automatic placement",
            "        - Matplotlib's algorithm finds position with minimal data overlap",
            "-       - Perfect for plots without titles (common in PRS manuscripts)",
            " ",
            "+    **Font Size Standardization:**",
            "+    ```python",
            "+    # Method 1: Manual standardization",
            "+    fontsize = 14",
            "+    ax.tick_params(labelsize=fontsize)",
            "+    ax.set_xlabel(\"Time\", fontsize=fontsize)",
            "+    ax.set_ylabel(\"Response\", fontsize=fontsize)",
            "+    prs_legend(ax, position=\"top\", fontsize=fontsize)",
            "+",
            "+    # Method 2: Helper function",
            "+    from prs_dataviz import set_axis_fontsize",
            "+    set_axis_fontsize(ax, fontsize=14)",
            "+    prs_legend(ax, position=\"top\", fontsize=14)",
            "+    ```",
            "+",
            "     **Usage Examples:**",
            "     ```python",
            "-    # Fully automatic (recommended)",
            "+    # Fully automatic (recommended for bar charts)",
            "     prs_legend(ax, position=\"top-smart\")",
            " ",
            "-    # Manual override if needed",
            "-    prs_legend(ax, position=\"top\", ncol=2)",
            "+    # With standardized font size",
            "+    prs_legend(ax, position=\"top\", fontsize=14)",
            " ",
            "     # Smart inside positioning (avoids data overlap)",
            "     prs_legend(ax, position=\"best\")",
            "     ```",
            " ",
            "     **Key Benefits:**",
            "+    - \u2705 Bar charts automatically get prominent handles",
            "     - \u2705 No manual `ncol` calculation needed",
            "-    - \u2705 Optimal positioning based on label length",
            "-    - \u2705 Consistent professional appearance",
            "+    - \u2705 Standardized font sizing across figure",
            "     - \u2705 Works perfectly for no-title plots (PRS standard)",
            " ",
            "-    **Use Cases:** Any plot with legends, especially when label lengths vary or you want automatic optimal layout",
            "+    **Use Cases:** Bar charts, stacked charts, any plot where you want automatic optimal legend layout",
            "     \"\"\"),",
            "         ]",
            "     )"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01JaJ4XvqPLEhykfkDM8kHQC"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Grep",
    "tool_input": {
      "pattern": "def set_axis_fontsize",
      "path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "output_mode": "content",
      "-C": 5,
      "-n": true
    },
    "tool_response": {
      "mode": "content",
      "numFiles": 0,
      "filenames": [],
      "content": "",
      "numLines": 0,
      "appliedLimit": 20
    },
    "tool_use_id": "toolu_01VTqhNywgeKxUwwv1i1QMCA"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "offset": 525,
      "limit": 30
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
        "content": "    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n",
        "numLines": 30,
        "startLine": 525,
        "totalLines": 741
      }
    },
    "tool_use_id": "toolu_0124jWEbATCWs6hwbtGSAzX6"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "def _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(",
      "new_string": "def _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, \"containers\") and ax.containers:\n        return True\n\n    return False\n\n\ndef set_axis_fontsize(ax, fontsize: int) -> None:\n    \"\"\"\n    Standardize font size across all text elements in axes.\n\n    Applies consistent font size to:\n    - Axis labels (xlabel, ylabel)\n    - Tick labels (x and y)\n    - Title (if present, uses fontsize + 2)\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to standardize.\n    fontsize : int\n        Font size in points (e.g., 12, 14, 16).\n\n    Examples\n    --------\n    Standardize entire figure typography:\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2], [3, 4], label=\"Data\")\n    >>> ax.set_xlabel(\"Category\")\n    >>> ax.set_ylabel(\"Value\")\n    >>> ax.set_title(\"Results\")\n    >>> set_axis_fontsize(ax, fontsize=14)\n    >>> prs_legend(ax, position=\"top\", fontsize=14)\n\n    Multiple subplots with consistent sizing:\n    >>> fig, (ax1, ax2) = plt.subplots(1, 2)\n    >>> # ... plotting ...\n    >>> for ax in [ax1, ax2]:\n    ...     set_axis_fontsize(ax, fontsize=14)\n    ...     prs_legend(ax, fontsize=14)\n\n    Notes\n    -----\n    This function modifies existing labels. For best results:\n    1. Create plot and set labels\n    2. Call set_axis_fontsize()\n    3. Call prs_legend() with same fontsize\n\n    The title receives fontsize + 2 for visual hierarchy.\n    \"\"\"\n    # Update tick label sizes\n    ax.tick_params(axis=\"both\", labelsize=fontsize)\n\n    # Update axis labels if they exist\n    if ax.get_xlabel():\n        current_xlabel = ax.get_xlabel()\n        ax.set_xlabel(current_xlabel, fontsize=fontsize, fontweight=\"bold\")\n\n    if ax.get_ylabel():\n        current_ylabel = ax.get_ylabel()\n        ax.set_ylabel(current_ylabel, fontsize=fontsize, fontweight=\"bold\")\n\n    # Update title if it exists (slightly larger)\n    if ax.get_title():\n        current_title = ax.get_title()\n        ax.set_title(current_title, fontsize=fontsize + 2, fontweight=\"bold\")\n\n\ndef prs_legend("
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "def _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(",
      "newString": "def _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, \"containers\") and ax.containers:\n        return True\n\n    return False\n\n\ndef set_axis_fontsize(ax, fontsize: int) -> None:\n    \"\"\"\n    Standardize font size across all text elements in axes.\n\n    Applies consistent font size to:\n    - Axis labels (xlabel, ylabel)\n    - Tick labels (x and y)\n    - Title (if present, uses fontsize + 2)\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to standardize.\n    fontsize : int\n        Font size in points (e.g., 12, 14, 16).\n\n    Examples\n    --------\n    Standardize entire figure typography:\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2], [3, 4], label=\"Data\")\n    >>> ax.set_xlabel(\"Category\")\n    >>> ax.set_ylabel(\"Value\")\n    >>> ax.set_title(\"Results\")\n    >>> set_axis_fontsize(ax, fontsize=14)\n    >>> prs_legend(ax, position=\"top\", fontsize=14)\n\n    Multiple subplots with consistent sizing:\n    >>> fig, (ax1, ax2) = plt.subplots(1, 2)\n    >>> # ... plotting ...\n    >>> for ax in [ax1, ax2]:\n    ...     set_axis_fontsize(ax, fontsize=14)\n    ...     prs_legend(ax, fontsize=14)\n\n    Notes\n    -----\n    This function modifies existing labels. For best results:\n    1. Create plot and set labels\n    2. Call set_axis_fontsize()\n    3. Call prs_legend() with same fontsize\n\n    The title receives fontsize + 2 for visual hierarchy.\n    \"\"\"\n    # Update tick label sizes\n    ax.tick_params(axis=\"both\", labelsize=fontsize)\n\n    # Update axis labels if they exist\n    if ax.get_xlabel():\n        current_xlabel = ax.get_xlabel()\n        ax.set_xlabel(current_xlabel, fontsize=fontsize, fontweight=\"bold\")\n\n    if ax.get_ylabel():\n        current_ylabel = ax.get_ylabel()\n        ax.set_ylabel(current_ylabel, fontsize=fontsize, fontweight=\"bold\")\n\n    # Update title if it exists (slightly larger)\n    if ax.get_title():\n        current_title = ax.get_title()\n        ax.set_title(current_title, fontsize=fontsize + 2, fontweight=\"bold\")\n\n\ndef prs_legend(",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, 'containers') and ax.containers:\n        return True\n\n    return False\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Auto-detect bar charts and apply prominent handle settings\n    is_bar = _is_bar_chart(ax)\n    if is_bar:\n        # Bar charts need larger, more visible legend handles\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n \n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n\n    # Common defaults (can be overridden by kwargs)\n    if fontsize is not None:\n        kwargs.setdefault(\"fontsize\", fontsize)\n    else:\n        kwargs.setdefault(\"fontsize\", 12)\n\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 547,
          "oldLines": 12,
          "newStart": 547,
          "newLines": 73,
          "lines": [
            "             return True",
            " ",
            "     # Also check containers (grouped/stacked bars)",
            "-    if hasattr(ax, 'containers') and ax.containers:",
            "+    if hasattr(ax, \"containers\") and ax.containers:",
            "         return True",
            " ",
            "     return False",
            " ",
            " ",
            "+def set_axis_fontsize(ax, fontsize: int) -> None:",
            "+    \"\"\"",
            "+    Standardize font size across all text elements in axes.",
            "+",
            "+    Applies consistent font size to:",
            "+    - Axis labels (xlabel, ylabel)",
            "+    - Tick labels (x and y)",
            "+    - Title (if present, uses fontsize + 2)",
            "+",
            "+    Parameters",
            "+    ----------",
            "+    ax : matplotlib.axes.Axes",
            "+        Axes to standardize.",
            "+    fontsize : int",
            "+        Font size in points (e.g., 12, 14, 16).",
            "+",
            "+    Examples",
            "+    --------",
            "+    Standardize entire figure typography:",
            "+    >>> fig, ax = plt.subplots()",
            "+    >>> ax.bar([1, 2], [3, 4], label=\"Data\")",
            "+    >>> ax.set_xlabel(\"Category\")",
            "+    >>> ax.set_ylabel(\"Value\")",
            "+    >>> ax.set_title(\"Results\")",
            "+    >>> set_axis_fontsize(ax, fontsize=14)",
            "+    >>> prs_legend(ax, position=\"top\", fontsize=14)",
            "+",
            "+    Multiple subplots with consistent sizing:",
            "+    >>> fig, (ax1, ax2) = plt.subplots(1, 2)",
            "+    >>> # ... plotting ...",
            "+    >>> for ax in [ax1, ax2]:",
            "+    ...     set_axis_fontsize(ax, fontsize=14)",
            "+    ...     prs_legend(ax, fontsize=14)",
            "+",
            "+    Notes",
            "+    -----",
            "+    This function modifies existing labels. For best results:",
            "+    1. Create plot and set labels",
            "+    2. Call set_axis_fontsize()",
            "+    3. Call prs_legend() with same fontsize",
            "+",
            "+    The title receives fontsize + 2 for visual hierarchy.",
            "+    \"\"\"",
            "+    # Update tick label sizes",
            "+    ax.tick_params(axis=\"both\", labelsize=fontsize)",
            "+",
            "+    # Update axis labels if they exist",
            "+    if ax.get_xlabel():",
            "+        current_xlabel = ax.get_xlabel()",
            "+        ax.set_xlabel(current_xlabel, fontsize=fontsize, fontweight=\"bold\")",
            "+",
            "+    if ax.get_ylabel():",
            "+        current_ylabel = ax.get_ylabel()",
            "+        ax.set_ylabel(current_ylabel, fontsize=fontsize, fontweight=\"bold\")",
            "+",
            "+    # Update title if it exists (slightly larger)",
            "+    if ax.get_title():",
            "+        current_title = ax.get_title()",
            "+        ax.set_title(current_title, fontsize=fontsize + 2, fontweight=\"bold\")",
            "+",
            "+",
            " def prs_legend(",
            "     ax,",
            "     *args,"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01FM5N6b5VsuL3n4SxShgFW5"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Edit",
    "tool_input": {
      "file_path": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "old_string": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:",
      "new_string": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int | None = None,\n    fontsize: int | None = None,\n    **kwargs\n) -> None:"
    },
    "tool_response": {
      "filePath": "/Users/shakes/DevProjects/prs-dataviz/src/prs_dataviz/style.py",
      "oldString": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:",
      "newString": "def prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int | None = None,\n    fontsize: int | None = None,\n    **kwargs\n) -> None:",
      "originalFile": "\"\"\"\nProfessional matplotlib styling for PRS journal submissions.\n\nApplies clean, professional styling appropriate for medical/surgical publications:\n- High contrast for clarity\n- Professional fonts\n- Clean, minimal design\n- Print-friendly defaults\n\nReference: Cara Thompson's 10-step design system methodology\nhttps://www.cararthompson.com/talks/on-brand-accessibility/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nfrom matplotlib import font_manager\n\nfrom .palettes import (\n    PRS_CLINICAL_CYCLE,\n    PRS_COMPARISON_CYCLE,\n    PRS_DEFAULT_CYCLE,\n)\n\n# ============================================================================\n# Style Application\n# ============================================================================\n\n\ndef apply_prs_style(\n    *,\n    cycle: str = \"default\",\n    font_family: str | list[str] = \"DejaVu Sans\",\n    font_size: int = 10,\n    show_grid: bool = False,\n    show_spines: bool = True,\n    custom_font_paths: list[str] | None = None,\n) -> None:\n    \"\"\"\n    Apply PRS-compliant styling to matplotlib globally.\n\n    Parameters\n    ----------\n    cycle : str, default \"default\"\n        Color cycle to use:\n        - \"default\": Professional categorical palette\n        - \"clinical\": Muted clinical data palette\n        - \"comparison\": Before/after comparison palette\n    font_family : str or list[str], default \"DejaVu Sans\"\n        Font family or fallback chain. DejaVu Sans is recommended for\n        professional medical publications.\n    font_size : int, default 10\n        Base font size in points.\n    show_grid : bool, default False\n        Whether to show grid lines. Generally False for medical images.\n    show_spines : bool, default True\n        Whether to show axis spines. Generally True for medical data.\n    custom_font_paths : list[str] or None, default None\n        Optional paths to custom font files to register.\n\n    Examples\n    --------\n    >>> apply_prs_style(cycle=\"default\")\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 4, 9])\n\n    >>> # For before/after comparisons\n    >>> apply_prs_style(cycle=\"comparison\")\n\n    >>> # For clinical data with grid\n    >>> apply_prs_style(cycle=\"clinical\", show_grid=True)\n    \"\"\"\n    # Register custom fonts if provided\n    if custom_font_paths is not None:\n        for font_path in custom_font_paths:\n            font_manager.fontManager.addfont(font_path)\n\n    # Select color cycle\n    if cycle == \"default\":\n        color_cycle = PRS_DEFAULT_CYCLE\n    elif cycle == \"clinical\":\n        color_cycle = PRS_CLINICAL_CYCLE\n    elif cycle == \"comparison\":\n        color_cycle = PRS_COMPARISON_CYCLE\n    else:\n        raise ValueError(\n            f\"Unknown cycle '{cycle}'. Use 'default', 'clinical', or 'comparison'\"\n        )\n\n    # Apply rcParams\n    plt.rcParams.update(\n        {\n            # Figure settings\n            \"figure.facecolor\": \"white\",\n            \"figure.dpi\": 100,  # Screen DPI (use save_prs_figure for print DPI)\n            \"figure.autolayout\": False,\n            # Axes settings\n            \"axes.facecolor\": \"white\",\n            \"axes.edgecolor\": \"#333333\",\n            \"axes.linewidth\": 1.0,\n            \"axes.grid\": show_grid,\n            \"axes.spines.top\": False,\n            \"axes.spines.right\": False,\n            \"axes.spines.left\": show_spines,\n            \"axes.spines.bottom\": show_spines,\n            \"axes.labelcolor\": \"#333333\",\n            \"axes.labelsize\": font_size,\n            \"axes.titlesize\": font_size + 2,\n            \"axes.titleweight\": \"bold\",\n            \"axes.titlepad\": 10,\n            # Color cycle\n            \"axes.prop_cycle\": cycler(color=color_cycle),\n            # Grid settings\n            \"grid.alpha\": 0.3,\n            \"grid.color\": \"#CCCCCC\",\n            \"grid.linestyle\": \"-\",\n            \"grid.linewidth\": 0.5,\n            # Ticks\n            \"xtick.bottom\": show_spines,\n            \"xtick.top\": False,\n            \"xtick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"xtick.color\": \"#333333\",\n            \"xtick.direction\": \"out\",\n            \"ytick.left\": show_spines,\n            \"ytick.right\": False,\n            \"ytick.labelsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"ytick.color\": \"#333333\",\n            \"ytick.direction\": \"out\",\n            # Font settings\n            \"font.family\": [font_family]\n            if isinstance(font_family, str)\n            else font_family,\n            \"font.size\": font_size,\n            \"text.color\": \"#333333\",\n            # Legend\n            \"legend.frameon\": True,\n            \"legend.framealpha\": 1.0,\n            \"legend.facecolor\": \"white\",\n            \"legend.edgecolor\": \"#CCCCCC\",\n            \"legend.fontsize\": font_size,  # Increased from font_size - 1 for accessibility\n            \"legend.title_fontsize\": font_size,\n            \"legend.borderpad\": 0.5,\n            \"legend.labelspacing\": 0.5,\n            # Lines\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"lines.markeredgewidth\": 0.5,\n            \"lines.markeredgecolor\": \"auto\",\n            # Patches (bars, etc.)\n            \"patch.linewidth\": 0.5,\n            \"patch.edgecolor\": \"#333333\",\n            \"patch.force_edgecolor\": False,\n            # Saving figures\n            \"savefig.dpi\": 300,  # High DPI for saving\n            \"savefig.facecolor\": \"white\",\n            \"savefig.edgecolor\": \"white\",\n            \"savefig.bbox\": \"tight\",\n            \"savefig.pad_inches\": 0.1,\n        }\n    )\n\n\n# ============================================================================\n# Specialized Styling Functions\n# ============================================================================\n\n\ndef format_statistical_plot(\n    ax,\n    show_significance: bool = True,\n    p_value_threshold: float = 0.05,\n) -> None:\n    \"\"\"\n    Format a plot for statistical data with significance indicators.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    show_significance : bool, default True\n        Whether to show significance indicators.\n    p_value_threshold : float, default 0.05\n        Threshold for statistical significance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [10, 15])\n    >>> format_statistical_plot(ax)\n    \"\"\"\n    # Ensure grid for data reading\n    ax.yaxis.grid(True, linestyle=\"--\", alpha=0.3)\n    ax.set_axisbelow(True)\n\n    # Clean up spines\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\ndef format_comparison_plot(ax, comparison_type: str = \"before_after\") -> None:\n    \"\"\"\n    Format a plot for before/after or treatment comparisons.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to format.\n    comparison_type : str, default \"before_after\"\n        Type of comparison: \"before_after\" or \"control_treatment\".\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], [1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], [2, 3, 4], label=\"After\")\n    >>> format_comparison_plot(ax, comparison_type=\"before_after\")\n    \"\"\"\n    # Set appropriate colors based on comparison type\n    if comparison_type == \"before_after\":\n        colors = PRS_COMPARISON_CYCLE\n    else:\n        colors = PRS_CLINICAL_CYCLE[:2]\n\n    # Update line colors if lines exist\n    lines = ax.get_lines()\n    for i, line in enumerate(lines[: len(colors)]):\n        line.set_color(colors[i])\n\n\ndef add_significance_indicator(\n    ax,\n    x: float,\n    y: float,\n    p_value: float = None,\n    symbol: str = \"*\",\n    bracket: bool = False,\n    x_start: float = None,\n    x_end: float = None,\n    show_p_value: bool = True,\n    **kwargs,\n) -> None:\n    \"\"\"\n    Add statistical significance indicator to a plot following publication best practices.\n\n    Scientific Standard: Show EITHER symbols (*,**,***) OR exact p-values, not both.\n    Based on research from matplotlib best practices, starbars package design,\n    and scientific publication conventions.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add indicator to.\n    x : float\n        X-coordinate for indicator (center of bracket if bracket=True).\n    y : float\n        Y-coordinate for bracket base (should be above compared bars).\n    p_value : float, optional\n        P-value for auto-formatting. Used to show exact value if show_p_value=True.\n    symbol : str, default \"*\"\n        Significance symbol (e.g., \"*\", \"**\", \"***\", \"ns\").\n        Ignored if show_p_value=True.\n    bracket : bool, default False\n        Whether to draw a horizontal bracket line with vertical tips.\n    x_start : float, optional\n        Starting x-coordinate for bracket (required if bracket=True).\n    x_end : float, optional\n        Ending x-coordinate for bracket (required if bracket=True).\n    show_p_value : bool, default True\n        If True, show exact p-value instead of symbol.\n        If False, show symbol only.\n        Recommendation: p-values for precision (default), symbols for visual clarity.\n    **kwargs\n        Additional formatting:\n        - text_fontsize: Annotation text size (default: 14pt symbols, 10pt p-values)\n        - text_color: Annotation color (default: #2C5F87)\n        - line_width: Bracket line width (default: 1.5)\n        - tip_length: Bracket tip length as % of y-range (default: 0.01 = 1%)\n        - text_offset: Bracket-to-text spacing as % of y-range (default: 0.01 = 1%)\n\n    Examples\n    --------\n    Symbol only (standard):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar(['Control', 'Treatment'], [65, 88])\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=\"**\",\n    ...                            bracket=True, x_start=0, x_end=1)\n\n    Exact p-value (when precision needed):\n    >>> add_significance_indicator(ax, x=0.5, y=90, p_value=0.023,\n    ...                            bracket=True, x_start=0, x_end=1,\n    ...                            show_p_value=True)\n\n    Auto-select symbol:\n    >>> from prs_dataviz import get_significance_symbol\n    >>> symbol = get_significance_symbol(0.008)  # Returns \"**\"\n    >>> add_significance_indicator(ax, x=0.5, y=90, symbol=symbol,\n    ...                            bracket=True, x_start=0, x_end=1)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    # Get current font size from rcParams\n    base_fontsize = plt.rcParams.get(\"font.size\", 10)\n\n    # Calculate y-range for relative positioning\n    y_range = ax.get_ylim()[1] - ax.get_ylim()[0]\n\n    # Spacing parameters (research-based defaults: 2-3% is standard)\n    tip_length_pct = kwargs.get(\"tip_length\", 0.01)  # 1% for bracket tips\n    text_offset_pct = kwargs.get(\n        \"text_offset\", 0.01\n    )  # 1% between bracket and text (compact)\n\n    # Convert to absolute values\n    tip_length = tip_length_pct * y_range\n    text_offset = text_offset_pct * y_range\n\n    # Draw bracket if requested\n    if bracket and x_start is not None and x_end is not None:\n        # Bold, prominent brackets for clear visibility (especially with gridlines)\n        line_width = kwargs.get(\"line_width\", 2.5)  # Bold brackets (was 1.5, then 2.0)\n        bracket_color = kwargs.get(\"bracket_color\", \"#000000\")  # Solid black\n\n        # Clean bracket structure: [x1, x1, x2, x2] and [y1, y2, y2, y1]\n        # Creates: tip down \u2192 horizontal \u2192 tip down\n        bracket_x = [x_start, x_start, x_end, x_end]\n        bracket_y = [y - tip_length, y, y, y - tip_length]\n\n        ax.plot(\n            bracket_x,\n            bracket_y,\n            color=bracket_color,\n            linewidth=line_width,\n            solid_capstyle=\"butt\",\n            zorder=100,\n        )\n\n    # Determine display: symbol OR p-value (not both)\n    if show_p_value and p_value is not None:\n        # Show exact p-value\n        if p_value < 0.001:\n            display_text = \"p < 0.001\"\n        elif p_value < 0.01:\n            display_text = f\"p = {p_value:.3f}\"\n        else:\n            display_text = f\"p = {p_value:.2f}\"\n\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize)  # 10pt\n        text_color = kwargs.get(\"text_color\", \"#666\")\n        text_weight = \"normal\"\n    else:\n        # Show symbol (standard practice)\n        display_text = symbol\n        text_fontsize = kwargs.get(\"text_fontsize\", base_fontsize + 4)  # 14pt\n        text_color = kwargs.get(\"text_color\", \"#2C5F87\")\n        text_weight = \"bold\"\n\n    # Position text above bracket\n    text_y = y + text_offset\n\n    # Add annotation\n    ax.text(\n        x,\n        text_y,\n        display_text,\n        fontsize=text_fontsize,\n        ha=\"center\",\n        va=\"bottom\",\n        color=text_color,\n        fontweight=text_weight,\n    )\n\n\ndef add_scale_bar(\n    ax, length: float, label: str, location: str = \"lower right\", **kwargs\n) -> None:\n    \"\"\"\n    Add a scale bar to a medical image (PRS prefers scale bars over magnification text).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes containing the image.\n    length : float\n        Length of scale bar in data coordinates.\n    label : str\n        Label for scale bar (e.g., \"100 \u03bcm\", \"1 cm\").\n    location : str, default \"lower right\"\n        Location of scale bar: \"lower left\", \"lower right\", \"upper left\", \"upper right\".\n    **kwargs\n        Additional arguments for scale bar appearance.\n\n    Examples\n    --------\n    >>> fig, ax = plt.subplots()\n    >>> ax.imshow(microscopy_image)\n    >>> add_scale_bar(ax, length=100, label=\"100 \u03bcm\")\n    \"\"\"\n    from matplotlib.lines import Line2D\n\n    # Get axes limits\n    xlim = ax.get_xlim()\n    ylim = ax.get_ylim()\n\n    # Calculate position based on location\n    margin = 0.05  # 5% margin from edges\n    if \"right\" in location:\n        x_pos = xlim[1] - (xlim[1] - xlim[0]) * margin - length\n    else:  # left\n        x_pos = xlim[0] + (xlim[1] - xlim[0]) * margin\n\n    if \"lower\" in location:\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * margin\n    else:  # upper\n        y_pos = ylim[1] - (ylim[1] - ylim[0]) * margin\n\n    # Scale bar properties\n    bar_height = kwargs.get(\"height\", (ylim[1] - ylim[0]) * 0.01)\n    bar_color = kwargs.get(\"color\", \"white\")\n    bar_linewidth = kwargs.get(\"linewidth\", 2)\n\n    # Add scale bar\n    scale_bar = Line2D(\n        [x_pos, x_pos + length],\n        [y_pos, y_pos],\n        linewidth=bar_linewidth,\n        color=bar_color,\n        solid_capstyle=\"butt\",\n    )\n    ax.add_line(scale_bar)\n\n    # Add label\n    label_color = kwargs.get(\"label_color\", bar_color)\n    label_size = kwargs.get(\"label_size\", 8)\n\n    ax.text(\n        x_pos + length / 2,\n        y_pos + bar_height * 2,\n        label,\n        color=label_color,\n        fontsize=label_size,\n        ha=\"center\",\n        va=\"bottom\",\n        weight=\"bold\",\n    )\n\n\n# ============================================================================\n# Legend Helpers\n# ============================================================================\n\n\ndef _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4):\n    \"\"\"\n    Calculate optimal number of columns for legend based on label lengths.\n\n    Parameters\n    ----------\n    labels : list of str\n        Legend labels.\n    max_label_length : int, default 20\n        Maximum characters before preferring fewer columns.\n    max_cols : int, default 4\n        Maximum number of columns to use.\n\n    Returns\n    -------\n    int\n        Optimal number of columns (1-max_cols).\n\n    Examples\n    --------\n    >>> labels = [\"Short\", \"A bit longer\"]\n    >>> _calculate_optimal_ncol(labels)\n    2\n\n    >>> labels = [\"Very long description text\", \"Another long one\"]\n    >>> _calculate_optimal_ncol(labels)\n    1\n    \"\"\"\n    if not labels:\n        return 1\n\n    n_labels = len(labels)\n    avg_length = sum(len(str(label)) for label in labels) / n_labels\n    max_length = max(len(str(label)) for label in labels)\n\n    # Decision logic:\n    # - Short labels (avg < 15 chars): Use more columns\n    # - Medium labels (15-25 chars): Use 2-3 columns\n    # - Long labels (> 25 chars): Use 1-2 columns\n\n    if max_length > 40:\n        # Very long labels - force single column\n        return 1\n    elif avg_length > 25:\n        # Long labels - prefer 1-2 columns\n        return min(2, n_labels)\n    elif avg_length > 15:\n        # Medium labels - prefer 2-3 columns\n        return min(3, max(2, n_labels // 2))\n    else:\n        # Short labels - can use more columns\n        # Use sqrt rule for small counts, otherwise max_cols\n        if n_labels <= 4:\n            return min(max_cols, n_labels)\n        else:\n            import math\n            return min(max_cols, int(math.ceil(math.sqrt(n_labels))))\n\n\ndef _get_legend_labels(ax):\n    \"\"\"\n    Extract legend labels from axes.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to extract labels from.\n\n    Returns\n    -------\n    list of str\n        Legend labels.\n    \"\"\"\n    handles, labels = ax.get_legend_handles_labels()\n    return labels\n\n\ndef _is_bar_chart(ax):\n    \"\"\"\n    Detect if axes contains bar chart (bar or barh plot).\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to check.\n\n    Returns\n    -------\n    bool\n        True if axes contains bar patches (bar chart).\n    \"\"\"\n    from matplotlib.patches import Rectangle\n\n    # Check if any patches are bar-like (rectangles)\n    for patch in ax.patches:\n        if isinstance(patch, Rectangle):\n            return True\n\n    # Also check containers (grouped/stacked bars)\n    if hasattr(ax, \"containers\") and ax.containers:\n        return True\n\n    return False\n\n\ndef set_axis_fontsize(ax, fontsize: int) -> None:\n    \"\"\"\n    Standardize font size across all text elements in axes.\n\n    Applies consistent font size to:\n    - Axis labels (xlabel, ylabel)\n    - Tick labels (x and y)\n    - Title (if present, uses fontsize + 2)\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to standardize.\n    fontsize : int\n        Font size in points (e.g., 12, 14, 16).\n\n    Examples\n    --------\n    Standardize entire figure typography:\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2], [3, 4], label=\"Data\")\n    >>> ax.set_xlabel(\"Category\")\n    >>> ax.set_ylabel(\"Value\")\n    >>> ax.set_title(\"Results\")\n    >>> set_axis_fontsize(ax, fontsize=14)\n    >>> prs_legend(ax, position=\"top\", fontsize=14)\n\n    Multiple subplots with consistent sizing:\n    >>> fig, (ax1, ax2) = plt.subplots(1, 2)\n    >>> # ... plotting ...\n    >>> for ax in [ax1, ax2]:\n    ...     set_axis_fontsize(ax, fontsize=14)\n    ...     prs_legend(ax, fontsize=14)\n\n    Notes\n    -----\n    This function modifies existing labels. For best results:\n    1. Create plot and set labels\n    2. Call set_axis_fontsize()\n    3. Call prs_legend() with same fontsize\n\n    The title receives fontsize + 2 for visual hierarchy.\n    \"\"\"\n    # Update tick label sizes\n    ax.tick_params(axis=\"both\", labelsize=fontsize)\n\n    # Update axis labels if they exist\n    if ax.get_xlabel():\n        current_xlabel = ax.get_xlabel()\n        ax.set_xlabel(current_xlabel, fontsize=fontsize, fontweight=\"bold\")\n\n    if ax.get_ylabel():\n        current_ylabel = ax.get_ylabel()\n        ax.set_ylabel(current_ylabel, fontsize=fontsize, fontweight=\"bold\")\n\n    # Update title if it exists (slightly larger)\n    if ax.get_title():\n        current_title = ax.get_title()\n        ax.set_title(current_title, fontsize=fontsize + 2, fontweight=\"bold\")\n\n\ndef prs_legend(\n    ax,\n    *args,\n    position: str = \"best\",\n    compact: bool = False,\n    ncol: int = None,\n    fontsize: int = None,\n    **kwargs\n) -> None:\n    \"\"\"\n    Create a PRS-style legend with professional formatting and smart positioning.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Axes to add legend to.\n    position : str, default \"best\"\n        Legend position. Options:\n        - \"best\": Automatic optimal placement avoiding data overlap (recommended)\n        - \"outside\": Right side, outside plot area\n        - \"top\": Above plot, compact horizontal layout\n        - \"top-smart\": Above plot with auto-calculated columns and positioning\n        - Any matplotlib location string: \"upper left\", \"lower right\", etc.\n    compact : bool, default False\n        If True, use compact spacing optimized for multi-column legends.\n        Recommended for 2+ columns.\n    ncol : int, optional\n        Number of columns. If None, automatically calculated based on:\n        - Number of labels\n        - Label text length\n        - Position type (more columns for \"top\", fewer for vertical positions)\n    fontsize : int, optional\n        Font size for legend text. If None, uses matplotlib default (usually 10-12).\n        Recommended: Use same fontsize for axes labels, tick labels, and legend\n        for consistent professional appearance.\n    *args, **kwargs\n        Additional arguments passed to ax.legend().\n        Common options: title, markerscale, bbox_to_anchor\n\n    Examples\n    --------\n    Smart auto-positioning (avoids overlap with data):\n    >>> fig, ax = plt.subplots()\n    >>> ax.plot([1, 2, 3], label=\"Before\")\n    >>> ax.plot([1, 2, 3], label=\"After\")\n    >>> prs_legend(ax)  # Uses position=\"best\"\n\n    Smart top positioning (auto-calculates columns):\n    >>> prs_legend(ax, position=\"top-smart\")\n\n    Standardized font size across figure:\n    >>> fontsize = 14\n    >>> ax.tick_params(labelsize=fontsize)\n    >>> ax.set_xlabel(\"Time\", fontsize=fontsize)\n    >>> ax.set_ylabel(\"Response\", fontsize=fontsize)\n    >>> prs_legend(ax, position=\"top\", fontsize=fontsize)\n\n    Bar chart with prominent legend (auto-detected):\n    >>> fig, ax = plt.subplots()\n    >>> ax.bar([1, 2, 3], [4, 5, 6], label=\"Treatment\")\n    >>> prs_legend(ax, position=\"top\")  # Auto-applies large handles for bars\n\n    Notes\n    -----\n    **Smart Column Calculation:**\n    When `ncol=None`, the function automatically determines optimal columns:\n    - Short labels (< 15 chars avg): 2-4 columns\n    - Medium labels (15-25 chars): 2-3 columns\n    - Long labels (> 25 chars): 1-2 columns\n    - Very long labels (> 40 chars): 1 column\n\n    **Smart Positioning:**\n    - `position=\"best\"` uses matplotlib's algorithm to avoid data overlap\n    - `position=\"top-smart\"` auto-positions above plot with optimal column count\n    - Works best for plots WITHOUT titles (common in PRS manuscripts)\n\n    **Auto-Detection for Bar Charts:**\n    When the axes contains bar charts (bar/barh), automatically applies:\n    - `markerscale=4` (4\u00d7 larger handles for visibility)\n    - `handleheight=2` (taller color boxes)\n    - `handlelength=2` (standard width)\n    These make bar chart legends more prominent and professional.\n\n    **Font Size Standardization:**\n    Use the same `fontsize` parameter for axes labels and legend:\n    ```python\n    fontsize = 14\n    ax.tick_params(labelsize=fontsize)\n    ax.set_xlabel(\"Label\", fontsize=fontsize)\n    prs_legend(ax, position=\"top\", fontsize=fontsize)\n    ```\n\n    **Position-Specific Defaults:**\n    - \"top\": Frameless, bbox_to_anchor adjusted based on ncol, compact spacing\n    - \"outside\": Framed, right side, vertically centered\n    - \"best\": Framed, automatic placement inside plot, avoids overlap\n    \"\"\"\n    # Auto-calculate ncol if not provided\n    if ncol is None:\n        labels = _get_legend_labels(ax)\n\n        if position in [\"top\", \"top-smart\"]:\n            # Top position: prefer more columns (horizontal layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=20, max_cols=4)\n        elif position == \"outside\":\n            # Outside position: prefer fewer columns (vertical layout)\n            ncol = _calculate_optimal_ncol(labels, max_label_length=30, max_cols=2)\n        else:\n            # Other positions: balanced approach\n            ncol = _calculate_optimal_ncol(labels, max_label_length=25, max_cols=3)\n\n    # Auto-detect bar charts and apply prominent handle settings\n    is_bar = _is_bar_chart(ax)\n    if is_bar:\n        # Bar charts need larger, more visible legend handles\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n\n    # Position-specific defaults\n    if position == \"outside\":\n        kwargs.setdefault(\"loc\", \"center left\")\n        kwargs.setdefault(\"bbox_to_anchor\", (1.02, 0.5))\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n    elif position in [\"top\", \"top-smart\"]:\n        # Professional top-aligned legend (frameless, compact)\n        # Adjust x position based on ncol for better centering\n        if ncol == 1:\n            x_anchor = 0.5  # Centered\n        elif ncol == 2:\n            x_anchor = 0.35  # Slightly left for 2 columns\n        elif ncol == 3:\n            x_anchor = 0.4   # Balanced for 3 columns\n        else:  # ncol >= 4\n            x_anchor = 0.45  # Nearly centered for 4+ columns\n\n        kwargs.setdefault(\"loc\", \"upper center\")\n        kwargs.setdefault(\"bbox_to_anchor\", (x_anchor, 1.12))\n        kwargs.setdefault(\"frameon\", False)\n        kwargs.setdefault(\"ncol\", ncol)\n        kwargs.setdefault(\"markerscale\", 4)\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n    elif position == \"best\":\n        # Smart positioning - matplotlib avoids data overlap\n        kwargs.setdefault(\"loc\", \"best\")\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n \n\n    else:\n        # Custom position (use matplotlib location string)\n        kwargs.setdefault(\"loc\", position)\n        kwargs.setdefault(\"frameon\", True)\n        kwargs.setdefault(\"framealpha\", 1.0)\n        kwargs.setdefault(\"edgecolor\", \"#CCCCCC\")\n        kwargs.setdefault(\"ncol\", ncol)\n\n\n    # Apply compact spacing if requested\n    if compact:\n        kwargs.setdefault(\"labelspacing\", 0.25)\n        kwargs.setdefault(\"handleheight\", 2)\n        kwargs.setdefault(\"handlelength\", 2)\n        kwargs.setdefault(\"columnspacing\", 0.75)\n\n\n    # Common defaults (can be overridden by kwargs)\n    if fontsize is not None:\n        kwargs.setdefault(\"fontsize\", fontsize)\n    else:\n        kwargs.setdefault(\"fontsize\", 12)\n\n    kwargs.setdefault(\"title\", \"\")\n\n    ax.legend(*args, **kwargs)\n",
      "structuredPatch": [
        {
          "oldStart": 619,
          "oldLines": 8,
          "newStart": 619,
          "newLines": 8,
          "lines": [
            "     *args,",
            "     position: str = \"best\",",
            "     compact: bool = False,",
            "-    ncol: int = None,",
            "-    fontsize: int = None,",
            "+    ncol: int | None = None,",
            "+    fontsize: int | None = None,",
            "     **kwargs",
            " ) -> None:",
            "     \"\"\""
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    },
    "tool_use_id": "toolu_01LhgbqUCuakGmfyUbS2dtDG"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "acceptEdits",
    "hook_event_name": "PostToolUse",
    "tool_name": "Bash",
    "tool_input": {
      "command": "uv run python -c \"from prs_dataviz import set_axis_fontsize, prs_legend; print('\u2705 Functions imported successfully')\"",
      "description": "Test import of new functions"
    },
    "tool_response": {
      "stdout": "\u2705 Functions imported successfully\nwarning: `VIRTUAL_ENV=/Users/shakes/.cache/uv/environments-v2/prs-gallery-e1acdad93779d5a6` does not match the project environment path `.venv` and will be ignored; use `--active` to target the active environment instead",
      "stderr": "",
      "interrupted": false,
      "isImage": false
    },
    "tool_use_id": "toolu_01Rxae3DUEePpncraJtb3keL"
  },
  {
    "session_id": "00529d73-01e8-4e21-bd12-db27cc0dea1b",
    "transcript_path": "/Users/shakes/.claude/projects/-Users-shakes-DevProjects-prs-dataviz/00529d73-01e8-4e21-bd12-db27cc0dea1b.jsonl",
    "cwd": "/Users/shakes/DevProjects/prs-dataviz",
    "permission_mode": "default",
    "hook_event_name": "PostToolUse",
    "tool_name": "Bash",
    "tool_input": {
      "command": "git status --short",
      "description": "Check git status to see modified files"
    },
    "tool_response": {
      "stdout": " M CLAUDE.md\n M notebooks/__marimo__/session/prs_gallery.py.json\n M notebooks/prs_gallery.py\n M pyproject.toml\n M src/prs_dataviz/__init__.py\n M src/prs_dataviz/export.py\n M src/prs_dataviz/helpers.py\n M src/prs_dataviz/layout.py\n M src/prs_dataviz/palettes.py\n M src/prs_dataviz/style.py\n?? .contextune/\n?? examples/\n?? logs/",
      "stderr": "",
      "interrupted": false,
      "isImage": false
    },
    "tool_use_id": "toolu_01GQ3ppQ6TPJww8XcLa69rzK"
  }
]